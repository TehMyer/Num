#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include common_scripts\utility;
// mo's menu ported to 360 by Jay Edited by Lost Whip
init()
{

	level.__VERSION__ = "v0.6";
	level.SELECTED_PREFIX = "^2-->^7";

	level thread setupMapSettings();
	level thread GlobalDefineOnce();

	setDvar("scr_" + level.gametype + "_scorelimit", 0);
	setDvar("scr_" + level.gametype + "_timelimit", 0);
	setDvar("scr_" + level.gametype + "_roundlimit", 0);
	setDvar("scr_" + level.gametype + "_numlives", 0);
	setDvar("scr_" + level.gametype + "_playerrespawndelay", 0);
	
	//Enable bounces/lunges
	setDvar("player_bayonetLaunchProof", 0);
	setDvar("player_bayonetLaunchZCap", 9999);
        // setDvar("player_bayonetLaunchDebugging", 1);

	setDvar("ui_hud_showobjicons", 0); // Hide objective icons from HUD and map

	setDvar("scr_game_perks", 0);			// Remove perks
	setDvar("scr_showperksonspawn", 0);		// Remove perks icons shown on spawn
	setDvar("scr_game_hardpoints", 0);		// Remove killstreaks

	setDvar("player_sprintUnlimited", 1);
        setDvar("jump_slowdownEnable", 0);
	
	
	// Remove fall damage
	setDvar("bg_fallDamageMaxHeight", 9999);
	setDvar("bg_fallDamageMinHeight", 9998);

	// Prevent bots from moving
	setDvar("sv_botsRandomInput", 0);
	setDvar("sv_botsPressAttackBtn", 0);
	

	level thread Colliderscript();

	level thread onPlayerConnect();
}

onPlayerConnect()
{
	for(;;)
	{
		level waittill("connecting", player);

		//ignore bots
		if(isDefined(player.pers["isBot"]))
			continue;

		//jump/crouch helper
		player setClientDvar("activeaction", "vstr start");
		player setClientDvar("start", "bind BUTTON_A vstr BUTTON_A_ACTION");
		player setClientDvar("BUTTON_A_ACTION", "+gostand;-gostand");

		player setupPlayer();
		player thread onPlayerSpawned();
	}
}

onPlayerSpawned()
{
	self endon("disconnect");

	for(;;)
	{
		self waittill("spawned_player");
		self thread ammoCheck();

                self initInfs();
                self thread doHax();
		self thread Defineonceplayervalue();
		self thread watchMeleeButtonPressed();
		self thread watchSecondaryOffhandButtonPressed();
		self thread watchFragButtonPressed();
		self thread updateSpeedometerHudElem();
		self thread watchDPAD_UP();
		self thread watchUseButtonPressed();
		self thread PlayerDefineOnce();
		self thread setupLoadout();

		self thread SpawnPlayerPlatform3();
		self thread SpawnPlayerPlatform();
		self thread initMenu();
		self thread InitBomb();
		self thread InitBomb2();
		self thread InitBomb3();
		self thread PlayerMenuColorPresets();
		self resetFOV();
                self iPrintln("^4mo^7's ported to WaW by ^4Jay ^7 Edited By ^4Lost Whip ^7:)");

		self maps\mp\gametypes\_squad::giveSquadFeatures();
	}
}

PlayerDefineOnce()
{
	self.menucolor = (0, 0, 0);
	self.menuhighlightcolor = (0, 0, 255);
	self.menutextcolor = "7";
	self.bomb1toggle = false;
	self.bomb2toggle = false;
	self.bomb3toggle = false;
	self.bomb4toggle = false;
	self.bomb1print = "";
	self.bomb2print = "";
	self.bomb3print = "";
	self.bomb4print = "";
	self.creditstart = false;
	self.originPrintActive = false;
}

GlobalDefineOnce()
{
	level.BarrierPos = false;
	level.selectbomb1 = "^1Bomb 1";
	level.selectbomb2 = "^1Bomb 2";
	level.selectbomb3 = "^1Bomb 3";
	level.selectbomb4 = "^1Bomb 4";
	level.bomb1user = "";
	level.bomb2user = "";
	level.bomb3user = "";
	level.bomb4user = "";
	level.barrierson = true;
	level.collideroriginalPOS = [];
	level.bombs = [];
	level.crates = [];
	level.hardcoreMode = true; //Force hardcore
	level.callbackPlayerDamage = ::blank; //Disable all damage
	level._effect["water"] = loadfx("explosions/grenadeExp_water");		
	
}
resetFOV()
{
	if(isdefined(self.cj["settings"]["cg_fov"]))
		self setClientDvar("cg_fov", self.cj["settings"]["cg_fov"]);
}

setupPlayer()
{
	self.cj = [];
	self.cj["saves"] = [];
	self.cj["bots"] = [];
	self.cj["botnumber"] = 0;
	self.cj["maxbots"] = 4;
	self.cj["settings"] = [];
	self.cj["settings"]["specialty_fastreload_enable"] = true;
	self.cj["settings"]["rpg_switch_enabled"] = false;
	self.cj["settings"]["rpg_switched"] = false;

	// Remove unlocalized errors
	self setClientDvars("loc_warnings","0","loc_warningsAsErrors","0","cg_errordecay","1","con_errormessagetime","0","uiscript_debug","0");

	// Set team names
	self setClientDvar("g_TeamName_Allies", "Jumpers");
	self setClientDvar("g_TeamName_Axis", "Bots");
	// TODO remove icons


	self setClientDvar("cg_overheadRankSize", 0);		// Remove overhead rank
	self setClientDvar("cg_overheadIconSize", 0);		// Remove overhead rank icon
	// self setClientDvar("cg_overheadNamesSize", 0);		// Remove overhead name

	// Remove objective waypoints on screen
	self setClientDvar("waypointIconWidth", 0.1);
	self setClientDvar("waypointIconHeight", 0.1);
	self setClientDvar("waypointOffscreenPointerWidth", 0.1);
	self setClientDvar("waypointOffscreenPointerHeight", 0.1);

	// Disable FX
	self setClientDvar("fx_enable", 0);
	self setClientDvar("fx_marks", 0);
	self setClientDvar("fx_marks_ents", 0);
	self setClientDvar("fx_marks_smodels", 0);

	// self setClientDvar("clanname", "");					// Remove clan tag
	self setClientDvar("motd", "CodJumper");

	self setClientDvar("aim_automelee_range", 0);		// Remove melee lunge

	// Disable autoaim for enemy players
	self setClientDvar("aim_slowdown_enabled", 0);
	self setClientDvar("aim_lockon_enabled", 0);

	// Don't show enemy player names
	self setClientDvar("cg_enemyNameFadeIn", 0);
	self setClientDvar("cg_enemyNameFadeOut", 0);

	// Always show enemies on the map but hide compass, can see enemy positions when pressing start
	self setClientDvar("g_compassShowEnemies", 1);
	self setClientDvar("compassSize", 0.001);

	self setClientDvar("cg_scoreboardPingText", 1);

}

initMenuOpts()
{
	self addMenu("main", "CodJumper " + level.__VERSION__, undefined);

	// Host submenu
	if(self GetEntityNumber() == 0)
	{		
		self addOpt("main", "[HOST] Global settings", ::subMenu, "host_menu");
		self addMenu("host_menu", "[HOST] Global settings", "main");
		self addOpt("host_menu", "Toggle jump_slowdownEnable", ::toggleJumpSlowdown);

		// Map selector
		self addOpt("main", "[HOST] Select map", ::subMenu, "host_menu_maps");
		self addMenu("host_menu_maps", "[HOST] Select map", "main");
		self addOpt("host_menu_maps", "Airfield", ::changeMap, "mp_airfield");
		self addOpt("host_menu_maps", "Asylum", ::changeMap, "mp_asylum");
		self addOpt("host_menu_maps", "Banzai", ::changeMap, "mp_kwai");
		self addOpt("host_menu_maps", "Castle", ::changeMap, "mp_castle");
		self addOpt("host_menu_maps", "Cliffside", ::changeMap, "mp_shrine");
		self addOpt("host_menu_maps", "Corrosion", ::changeMap, "mp_stalingrad");
		self addOpt("host_menu_maps", "Courtyard", ::changeMap, "mp_courtyard");
		self addOpt("host_menu_maps", "Dome", ::changeMap, "mp_dome");
		self addOpt("host_menu_maps", "Downfall", ::changeMap, "mp_downfall");
		self addOpt("host_menu_maps", "Hangar", ::changeMap, "mp_hangar");
		self addOpt("host_menu_maps", "Makin", ::changeMap, "mp_makin");
		self addOpt("host_menu_maps", "Knee Deep", ::changeMap, "mp_kneedeep");
		self addOpt("host_menu_maps", "Makin Day", ::changeMap, "mp_makin_day");
		self addOpt("host_menu_maps", "Nightfire", ::changeMap, "mp_nachtfeuer");
		self addOpt("host_menu_maps", "Outskirts", ::changeMap, "mp_outskirts");
		self addOpt("host_menu_maps", "Roundhouse", ::changeMap, "mp_roundhouse");
		self addOpt("host_menu_maps", "Seelow", ::changeMap, "mp_seelow");
		self addOpt("host_menu_maps", "Station", ::changeMap, "mp_subway");
		self addOpt("host_menu_maps", "Sub Pens", ::changeMap, "mp_docks");
		self addOpt("host_menu_maps", "Upheaval", ::changeMap, "mp_suburban");
	}

	// Loadout submenu 
	if(self.name == "User" || self.name == "Lost Whip")
	{
		self addOpt("main", "Whips SubMenu", ::subMenu, "Whip");
		self addMenu("Whip", "Whips SubMenu", "main");
		self addopt("Whip", "Display Model Postion n angles",::PrintEntityInfo,self);
		self addopt("Whip", "PrintAllEntities",::PrintAllEntities,self);
		self addopt("Whip", "printbrushmodels2",::printbrushmodels2,self);
//		self addopt("Whip", "InitTank1",::InitTank1,self);
//		self addopt("Whip", "InitTank2",::InitTank2,self);
//		self addopt("Whip", "Movetank",::Movetank,self);
//		self addopt("Whip", "Brightness +.1",::VisionTest2,self);
//		self addopt("Whip", "Brightness -.1",::VisionTest3,self);
//		self addopt("Whip", "Contrast +.1",::VisionTest4,self);
//		self addopt("Whip", "Contrast -.1",::VisionTest5,self);

		
		

	}

	// Loadout submenu
	self addOpt("main", "Loadout Menu", ::subMenu, "loadout_menu");
	self addMenu("loadout_menu", "Loadout Menu", "main");
	self addOpt("loadout_menu", "Sleight of Hand", ::toggleFastReload);
	self addOpt("loadout_menu", "RPG Switch", ::toggleRPGSwitch);
	self addOpt("loadout_menu", "Shotgun Mobility", ::shotgunMobility);
	self addOpt("loadout_menu", "SMG Mobility", ::smgMobility);
	self addOpt("loadout_menu", "Sniper Mobility", ::sniperMobility);
	self addOpt("loadout_menu", "LMG Mobility", ::lmgMobility);
	
	self addopt("main", "Credits",::startCreditsSequence,self);
	self addOpt("main", "Extras", ::subMenu, "Extras");
	self addMenu("Extras", "Extras", "main");
	self addOpt("Extras", "3rd Person", ::toggleThirdPerson);
	self addOpt("Extras", "cg_drawgun", ::toggleShowGun);
	self addOpt("Extras", "Player names", ::togglePlayerNames);
	self addOpt("Extras", "Gun bob", ::toggleGunBob);
	self addOpt("Extras", "Spectator buttons", ::toggleSpectatorButtons);
	self addOpt("Extras", "Speed + Height meter", ::toggleSpeedometerHudElem);
	self addOpt("Extras", "Jump Crouch", ::toggleJumpCrouch);
	self addOpt("Extras", "Film Effects", ::toggleFilmEffects);
	self addOpt("Extras", "FOV", ::toggleFOV);
	self addOpt("Extras", "r_zfar", ::toggle_r_zfar);
	self addOpt("Extras", "Fog", ::toggle_r_fog);
	self addOpt("Extras", "Depth of field", ::toggle_r_dof_enable);

	// Bot submenu
	self addOpt("main", "Bot Menu", ::subMenu, "bot_menu");
	self addMenu("bot_menu", "Bot Menu", "main");
	for (i = 0; i < self.cj["maxbots"]; i++)
	{
		text = "";
		if(self.cj["botnumber"] == i)
			text += level.SELECTED_PREFIX;

		text += "Set active bot " + (i + 1);
		// If bot is already spawned display its origin
		// useful to record good bot positions
		if(isplayer(self.cj["bots"][i]))
		{
			origin = self.cj["bots"][i].origin;
			origin = (int(origin[0]), int(origin[1]), int(origin[2]));
			text += (" " + origin);
		}

		self addOpt("bot_menu", text, ::setSelectedBot, i);
	}
	self addOpt("main", "Spawn clone", ::addClone);	
	
	// Menu Customization 
	self addOpt("main", "Menu Customization", ::subMenu, "menu_Customization");
	self addMenu("menu_Customization", "Menu Customization", "main");
	
	self addOpt("menu_Customization", "Base Menu Color", ::subMenu, "BaseColor");
	self addMenu("BaseColor", "Base Menu Color", "menu_Customization");
	self addOpt("BaseColor", "Dark Blue", ::menucolorblue);
	self addOpt("BaseColor", "Cyan", ::menucolorcyan);
	self addOpt("BaseColor", "Red", ::menucolorred);
	self addOpt("BaseColor", "Gold", ::menucolorgold);
	self addOpt("BaseColor", "Green", ::menucolorgreen);
	self addOpt("BaseColor", "Purple", ::menucolorpurple);
	self addOpt("BaseColor", "White", ::menucolorwhite);
	self addOpt("BaseColor", "Black", ::menucolorblack);
	self addOpt("BaseColor", "Reset All Colors", ::menucolorreset);

	self addOpt("menu_Customization", "Text Highlight Color", ::subMenu, "HighlightColor");
	self addMenu("HighlightColor", "Text Highlight Color", "menu_Customization");
	self addOpt("HighlightColor", "Dark Blue", ::menuhighlightcolorblue);
	self addOpt("HighlightColor", "Cyan", ::menuhighlightcolorcyan);
	self addOpt("HighlightColor", "Red", ::menuhighlightcolorred);
	self addOpt("HighlightColor", "Gold", ::menuhighlightcolorgold);
	self addOpt("HighlightColor", "Green", ::menuhighlightcolorgreen);
	self addOpt("HighlightColor", "Purple", ::menuhighlightcolorpurple);
	self addOpt("HighlightColor", "White", ::menuhighlightcolorwhite);
	self addOpt("HighlightColor", "Black", ::menuhighlightcolorblack);
	self addOpt("HighlightColor", "Reset All Colors", ::menucolorreset);

	self addOpt("menu_Customization", "Text Color", ::subMenu, "TextColor");
	self addMenu("TextColor", "Text Color", "menu_Customization");
	self addOpt("TextColor", "Blue", ::menutextcolorblue);
	self addOpt("TextColor", "Cyan", ::menutextcolorcyan);
	self addOpt("TextColor", "Red", ::menutextcolorred);
	self addOpt("TextColor", "Yellow", ::menutextcoloryellow);
	self addOpt("TextColor", "Green", ::menutextcolorgreen);
	self addOpt("TextColor", "Orange", ::menutextcolororange);
	self addOpt("TextColor", "White", ::menutextcolorwhite);
	self addOpt("TextColor", "Black", ::menutextcolorblack);
	self addOpt("TextColor", "Reset All Colors", ::menucolorreset);

	self addOpt("menu_Customization", "Color Schemes", ::subMenu, "Schemes");
	self addMenu("Schemes", "Color Schemes", "menu_Customization");
	self addOpt("Schemes", "Retro Scheme", ::menuretroscheme);
	self addOpt("Schemes", "Patriotic Scheme", ::menuPatrioticscheme);
	self addOpt("Schemes", "Monochrome Scheme", ::menumonochromescheme);
	self addOpt("Schemes", "Candy Scheme", ::menucandyscheme);
	self addOpt("Schemes", "Contrast Scheme", ::menuoldschoolscheme);
	self addOpt("Schemes", "Arcade Scheme", ::menuarcadescheme);
	self addOpt("Schemes", "Solstice Scheme", ::menuSolsticescheme);
	self addOpt("Schemes", "Verdant Scheme", ::menuVerdantscheme);

	// Bomb1
	self addOpt("main", "Bomb Options", ::subMenu, "menu_game_objects");
	self addMenu("menu_game_objects", "Bomb Options", "main");
	self addOpt("menu_game_objects", self.bomb1print + level.selectbomb1 + "^5[" + level.bomb1user + "^5]", ::Spawnbombtoggle1);
	self addOpt("menu_game_objects", self.bomb2print + level.selectbomb2 + "^5[" + level.bomb2user + "^5]", ::Spawnbombtoggle2);
	self addOpt("menu_game_objects", self.bomb3print + level.selectbomb3 + "^5[" + level.bomb3user + "^5]", ::Spawnbombtoggle3);
	self addOpt("menu_game_objects", self.bomb4print + level.selectbomb4 + "^5[" + level.bomb4user + "^5]", ::Spawnbombtoggle4);
	self addOpt("menu_game_objects", "Spawn Platform", ::moveplatform2);
	self addOpt("menu_game_objects", "Slope +10", ::slopebomb10);
	self addOpt("menu_game_objects", "Slope -10", ::slopebombminus10);
	self addOpt("menu_game_objects", "Rotate +10", ::rotatebomb10);
	self addOpt("menu_game_objects", "Rotate -10", ::rotatebombminus10);
	self addOpt("menu_game_objects", "Tilt +10", ::tiltbomb10);
	self addOpt("menu_game_objects", "Tilt -10", ::tiltbombminus10);
	self addOpt("menu_game_objects", "Reset", ::resetbomb10);
	self addOpt("menu_game_objects", "Spawn Platform", ::moveplatform2);
	self addopt("menu_game_objects", "Move Bounceable Car ^1 WIP",::moveslopedplatform2,self);
	self addOpt("menu_game_objects", "Toggle forge mode", ::ForgeONToggle);

	self addOpt("main", "Barrier Options", ::subMenu, "menu_Barrier");
	self addMenu("menu_Barrier", "Barrier Options", "main");
	self addopt("menu_Barrier", "Toggle Visible Barriers",::DisplayBarrierPostoggle,self);
	self addOpt("menu_Barrier", "Toggle Patched Barriers",::Barrierswitch,level);
	self addopt("menu_Barrier", "Print Position",::printorigin,self);


}

initMenu()
{
	self endon("death");
	self endon("disconnect");

	// Wait until the countdown period is over so player controls aren't unfrozen when menu is open
	if ( level.inPrematchPeriod )
	{
		level waittill("prematch_over");
	}

	level.SCROLL_TIME_SECONDS = 0.15;

	self.inMenu = undefined;

	self.currentMenu = "main";
	self.menuCurs = 0;

	for(;;)
	{
		if(isDefined(self.inMenu))
		{
			// Menu DOWN
			if(self attackButtonPressed())
			{
				self.menuCurs++;
				if(self.menuCurs > self.menuAction[self.currentMenu].opt.size-1)
					self.menuCurs = 0;
				self.scrollBar moveOverTime(level.SCROLL_TIME_SECONDS);
				self.scrollBar.y = ((self.menuCurs*17.98)+((self.menuText.y+1)-(17.98/2)));
				wait level.SCROLL_TIME_SECONDS;
			}

			// Menu UP
			if(self adsButtonPressed())
			{
				self.menuCurs--;
				if(self.menuCurs < 0)
					self.menuCurs = self.menuAction[self.currentMenu].opt.size-1;
				self.scrollBar moveOverTime(level.SCROLL_TIME_SECONDS);
				self.scrollBar.y = ((self.menuCurs*17.98)+((self.menuText.y+1)-(17.98/2)));
				wait level.SCROLL_TIME_SECONDS;
			}

			// MENU SELECT
			if(self useButtonPressed())
			{
				self thread [[self.menuAction[self.currentMenu].func[self.menuCurs]]](self.menuAction[self.currentMenu].inp[self.menuCurs]);
				wait .2;
			}

			// MENU CLOSE
			if(self meleeButtonPressed())
			{
				if(!isDefined(self.menuAction[self.currentMenu].parent))
				{
					self freezecontrols(false);
					self.inMenu = undefined;
					self.menuCurs = 0;

					self.instructionsBackground destroy();
					self.instructionsText destroy();
					self.openBox destroy();
					self.menuText destroy();
					self.scrollBar destroy();
					self.openText destroy();
					self.logobox1 destroy();
					self.logobox2 destroy();
					self.HelpText destroy();
					self.instructionsBackground2 destroy();
				}
				// Go back
				else
					self subMenu(self.menuAction[self.currentMenu].parent);
			}
		}
		wait .05;
	}
}

openCJ()
{
	if(!isDefined(self.inMenu))
	{
		self freezecontrols(true);
		self.inMenu = true;
		self initMenuOpts();
		menuOpts = self.menuAction[self.currentMenu].opt.size;

		self.instructionsBackground = self createRectangle("TOPLEFT", "LEFT", 5, -55, 200, 114, (0, 0, 0), "white", 4, (1/1.6));
		self.instructionsBackground2 = self createRectangle("TOPLEFT", "LEFT", 2, -58, 206, 120, (255, 255, 255), "white", 4, (1/1.6));
		self.logobox1 = self createRectangle("TOPLEFT", "LEFT", 5, -200, 200, 95, (0, 0, 0), "white", 4, (1/1.6)); // red
		self.logobox2 = self createRectangle("TOPLEFT", "LEFT", 2, -203, 206, 101, (25, 0, 0), "white", 4, (1/1.6)); // black
		
		HelpString = "           ^4Bind Controls\n[{+frag}] ^3= ^2UFO	 [{+actionslot 1}] ^3= ^2Bot\n[{+melee}] ^2x2 ^3= ^2SavePos \n[{+smoke}] ^3= ^2Load Postion\n[{+smoke}] ^1In UFO ^3= ^2Bomb";
		self.HelpText = self createText("default", 1.5, "TOPLEFT", "LEFT", 7, -199 ,100 ,1, (0, 0, 0) ,HelpString);
	
		instructionsString = "           ^4Menu Controls\n^7Press [{+activate}] to select item\nPress [{+attack}] [{+speed_throw}] to navigate Menu\nPress [{+melee}] to go back\n^1Bomb ^7= Useable\n^2Bomb ^7= In Use";
		self.instructionsText = self createText("default", 1.5, "TOPLEFT", "LEFT", 6, -54 ,100 ,1, (0, 0, 0) ,instructionsString);
		self.openBox = self createRectangle("TOP", "TOPRIGHT", -160, 10, 300, 445, self.menucolor, "white", 1, .7);
		self.openText = self createText("default", 1.5, "TOP", "TOPRIGHT", -160, 16, 2, 1, (0, 0, 255), self.menuAction[self.currentMenu].title);
		string = "";
		for(m = 0; m < menuOpts; m++)
			string+= "^"+self.menutextcolor+self.menuAction[self.currentMenu].opt[m]+"\n";
		self.menuText = self createText("default", 1.5, "LEFT", "TOPRIGHT", -300, 60, 3, 1, (0, 255, 0), string);
		self.scrollBar = self createRectangle("TOP", "TOPRIGHT", -160, ((self.menuCurs*17.98)+((self.menuText.y+1)-(17.98/2))), 300, 15, self.menuhighlightcolor, "white", 2, .7);
	}
}





watchUseButtonPressed()
{
	self endon("disconnect");
	self endon("killed_player");
	self endon("joined_spectators");

	for(;;)
	{
		if(!self.inMenu && self UseButtonPressed())
		{
			catch_next = false;

			for(i=0; i<=0.5; i+=0.05)
			{
				if(catch_next && self UseButtonPressed() && !(self isMantling()))
				{
					wait 0.1;
					thread openCJ();
					break;
				}
				else if(!(self UseButtonPressed()))
					catch_next = true;

				wait 0.05;
			}
		}

		wait 0.05;
	}
}

subMenu(menu)
{
	self.menuCurs = 0;
	self.currentMenu = menu;
	self.scrollBar moveOverTime(.2);
	self.scrollBar.y = ((self.menuCurs*17.98)+((self.menuText.y+1)-(17.98/2)));
	self.menuText destroy();
	self initMenuOpts();
	self.openText setText(self.menuAction[self.currentMenu].title);
	menuOpts = self.menuAction[self.currentMenu].opt.size;

	wait .2;
	string = "";
	for(m = 0; m < menuOpts; m++)
		string+= "^"+self.menutextcolor+self.menuAction[self.currentMenu].opt[m]+"\n";
	self.menuText = self createText("default", 1.5, "LEFT", "TOPRIGHT", -300, 60, 3, 1, undefined, string);
	wait .2;
}

refreshMenu()
{
	self.menuText destroy();
	self initMenuOpts();
	self.openText setText(self.menuAction[self.currentMenu].title);
	menuOpts = self.menuAction[self.currentMenu].opt.size;
	string = "";
	for(m = 0; m < menuOpts; m++)
		string+= "^"+self.menutextcolor+self.menuAction[self.currentMenu].opt[m]+"\n";
	self.menuText = self createText("default", 1.5, "LEFT", "TOPRIGHT", -300, 60, 3, 1, undefined, string);
}

addMenu(menu, title, parent)
{
	if(!isDefined(self.menuAction))
		self.menuAction = [];
	self.menuAction[menu] = spawnStruct();
	self.menuAction[menu].title = title;
	self.menuAction[menu].parent = parent;
	self.menuAction[menu].opt = [];
	self.menuAction[menu].func = [];
	self.menuAction[menu].inp = [];
}

addOpt(menu, opt, func, inp)
{
	m = self.menuAction[menu].opt.size;
	self.menuAction[menu].opt[m] = opt;
	self.menuAction[menu].func[m] = func;
	self.menuAction[menu].inp[m] = inp;
}

createText(font, fontScale, align, relative, x, y, sort, alpha, glow, text)
{
	textElem = self createFontString(font, fontScale, self);
	textElem setPoint(align, relative, x, y);
	textElem.sort = sort;
	textElem.alpha = alpha;
	textElem.glowColor = glow;
	textElem.glowAlpha = 1;
	textElem setText(text);
	self thread destroyOnDeath(textElem);
	return textElem;
}
createRectangle(align, relative, x, y, width, height, color, shader, sort, alpha)
{
	boxElem = newClientHudElem(self);
	boxElem.elemType = "bar";
	if(!level.splitScreen)
	{
		boxElem.x = -2;
		boxElem.y = -2;
	}
	boxElem.width = width;
	boxElem.height = height;
	boxElem.align = align;
	boxElem.relative = relative;
	boxElem.xOffset = 0;
	boxElem.yOffset = 0;
	boxElem.children = [];
	boxElem.sort = sort;
	boxElem.color = color;
	boxElem.alpha = alpha;
	boxElem setParent(level.uiParent);
	boxElem setShader(shader, width, height);
	boxElem.hidden = false;
	boxElem setPoint(align, relative, x, y);
	self thread destroyOnDeath(boxElem);
	return boxElem;
}

destroyOnDeath(elem)
{
	self waittill_any("death", "disconnect");
	if(isDefined(elem.bar))
		elem destroyElem();
	else
		elem destroy();
}

ammoCheck()
{
	self endon("death");
	self endon("disconnect");
	self endon("game_ended");

	for (;;)
	{
		currentWeapon = self getCurrentWeapon();
		if (!self isMantling() && !self isOnLadder() && self getAmmoCount(currentWeapon) <= weaponClipSize(currentWeapon))
		{
			self giveMaxAmmo(currentWeapon);
		}
		wait 2;
	}
}

setupLoadout()
{

	if(self.cj["settings"]["specialty_fastreload_enable"] == true)
	{
		self setPerk("specialty_fastreload");	// Give Sleight of Hand
	}

        self takeWeapon("sticky_grenade_mp"); // Sticky
        self takeWeapon("frag_grenade_mp"); // Frag
        self takeWeapon("smoke_grenade_mp"); // Smoke
        self takeWeapon("flash_grenade_mp"); // Flash
        self takeWeapon("tabun_gas_mp"); // Conc
	self takeWeapon("flare_mp"); // Conc
}

watchMeleeButtonPressed()
{
	self endon("disconnect");
	self endon("killed_player");
	self endon("joined_spectators");

	for(;;)
	{
		if(!self.inMenu && self meleeButtonPressed())
		{
			catch_next = false;
			count = 0;

			for(i=0; i<0.5; i+=0.05)
			{
				if(catch_next && self meleeButtonPressed() && self isOnGround())
				{
					self thread savePos(1);
					wait .1;
					break;
				}
				else if(!(self meleeButtonPressed()) && !(self attackButtonPressed()))
					catch_next = true;

				wait 0.05;
			}
		}
		if(self.creditstart == true && self meleeButtonPressed())
		{
			self notify("Endcreditsbutton");
		}
		wait 0.05;
	}
}

watchSecondaryOffhandButtonPressed()
{
	self endon("disconnect");
	self endon("killed_player");
	self endon("joined_spectators");
	for(;;)
	{
		if(!self.inMenu && !self.cj["settings"]["ufo_mode"] && self secondaryOffhandButtonPressed())
		{
			self loadPos(1);
			wait .1;
		}
		if(self.cj["settings"]["ufo_mode"] == true && self secondaryOffhandButtonPressed() && self.bomb1toggle)
		{
			self thread MoveBomb();
			wait .1;
		}
		if(self.cj["settings"]["ufo_mode"] == true && self secondaryOffhandButtonPressed() && self.bomb2toggle)
		{
			self thread MoveBomb2();
			wait .1;
		}
		if(self.cj["settings"]["ufo_mode"] == true && self secondaryOffhandButtonPressed() && self.bomb3toggle)
		{
			self thread MoveBomb3();
			wait .1;
		}
		if(self.cj["settings"]["ufo_mode"] == true && self secondaryOffhandButtonPressed() && self.bomb4toggle)
		{
			self thread MoveBomb4();
			wait .1;
		}
		
		wait 0.05;
	}
}

watchFragButtonPressed()
{
	self endon("disconnect");
	self endon("killed_player");
	self endon("joined_spectators");

	for(;;)
	{
		if(self FragButtonPressed())
		{
			self thread toggleUFO();
			wait 0.5;
		}

		wait 0.05;
	}
}

savePos(i)
{
	wait 0.05;
	self.cj["settings"]["rpg_switched"] = false;
	self.cj["save"]["org"+i] = self.origin;
	self.cj["save"]["ang"+i] = self getPlayerAngles();
}

loadPos(i)
{
	self freezecontrols(true);
	wait 0.05;

	self setPlayerAngles(self.cj["save"]["ang"+i]);
	self setOrigin(self.cj["save"]["org"+i]);

	//pull out rpg on load if RPG switch is enabled
	if(self.cj["settings"]["rpg_switch_enabled"] && self.cj["settings"]["rpg_switched"])
	{
		self switchToWeapon("rpg_mp");
		self.cj["settings"]["rpg_switched"] = false;
	}

	wait 0.05;
	self freezecontrols(false);
}

initBot()
{
	bot = addtestclient();
	bot.pers["isBot"] = true;
	while (!isDefined(bot.pers["team"])) wait 0.05;
	bot notify("menuresponse", game["menu_team"], "axis");
	wait 0.5;
	bot.weaponPrefix = "ak47_mp";
	bot notify("menuresponse", "changeclass", "specops_mp");
	bot waittill("spawned_player");
	bot.selectedClass = true;
	while (bot.sessionstate != "playing") wait 0.05;
	bot FreezeControls(true);
	return bot;
}

watchDPAD_UP()
{
	self endon("death");
	self endon("disconnect");
	self endon("game_ended");

	self SetActionSlot( 1, "nightvision" );

	for(;;)
	{
		self waittill("weapon_change");

		if(self getCurrentWeapon() != "squadcommand_mp")
			continue;

		wait .05;

		self notify("cancel_location");

		self thread spawnSelectedBot();
	}
}

setSelectedBot(num)
{
	self.cj["botnumber"] = num;
	self iPrintLn("Bot " + (num + 1) + " active. Press [{+actionslot 1}] to update position.");
	self refreshMenu();
}

spawnSelectedBot()
{

	if(!isdefined(self.cj["bots"][self.cj["botnumber"]]))
	{
		self.cj["bots"][self.cj["botnumber"]] = initBot();
		if (!isdefined(self.cj["bots"][self.cj["botnumber"]]))
		{
			self iPrintLn("^1Couldn't spawn a bot");
			return;
		}
	}

	origin = self.origin;
	playerAngles = self getPlayerAngles();

	wait 0.5;
	for (i = 3; i > 0; i--)
	{
		self iPrintLn("Bot spawns in ^2" + i);
		wait 1;
	}
	self.cj["bots"][self.cj["botnumber"]] setOrigin(origin);
	// Face the bot the same direction the player was facing
	self.cj["bots"][self.cj["botnumber"]] setPlayerAngles((0, playerAngles[1], 0));
}

toggleJumpSlowdown()
{
	setting = "jump_slowdownEnable";
	printName = setting;

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		setDvar(setting, 0);
		iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		setDvar(setting, 1);
		iPrintln(printName + " [^2ON^7]");
	}
}

toggleShowGun()
{
	setting = "cg_drawgun";
	printName = setting;

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
}

toggleThirdPerson()
{
	setting = "cg_thirdPerson";
	printName = "3rd Person";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
}

toggleUFO()
{
	setting = "ufo_mode";
	printName = "UFO Mode";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self allowSpectateTeam("freelook", true);
		self.sessionstate = "spectator";
		wait 0.1;
		self resetFOV();
		self iPrintln(printName + " [^2ON^7]");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self allowSpectateTeam("freelook", false);
		self.sessionstate = "playing";
		wait 0.1;
		self resetFOV();
		self iPrintln(printName + " [^1OFF^7]");
	}
}

togglePlayerNames()
{
	setting = "cg_overheadnamessize";
	printName = "Player names";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 0.65);
		self iPrintln(printName + " [^2ON^7]");
	}
}

toggleGunBob()
{
	setting = "bg_bobMax";
	printName = "Gun bob";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 8);
		self iPrintln(printName + " [^2ON^7]");
	}
}

addClone()
{
	body = self clonePlayer(100000);
	self.cj["clones"][self.cj["clones"].size] = body;
}

switchDesertEagle()
{
	if(self.cj["settings"]["deserteagle_choice"] == "357magnum_mp")
		self.cj["settings"]["deserteagle_choice"] = "357magnum_mp";
	else
		self.cj["settings"]["deserteagle_choice"] = "357magnum_mp";

	self setupLoadout();
}

toggleFastReload()
{
	setting = "specialty_fastreload_enable";
	printName = "Sleight of Hand";

	if (self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self iPrintln(printName + " [^2ON^7]");
	}

	self setupLoadout();
}

changeMap(mapname)
{
	Map( mapname );
}

toggleSpectatorButtons()
{
	setting = "cg_drawSpectatorMessages";
	printName = "Spectator Buttons";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
}


linkScriptBrushModel(ent)
{
	brushModels = getEntArray("script_brushmodel", "classname");
	for (i = 0; i < brushModels.size; i++)
	{
		if(distance(ent.origin, brushModels[i].origin) < 80 && ent.script_gameobjectname == brushModels[i].script_gameobjectname)
		{
			brushModels[i] LinkTo(ent);
			break;
		}
	}
}

spawnGameObject()
{
	playerAngles = self getPlayerAngles();
	ent = self.activeGameObject;
	ent.origin = self.origin + (anglestoforward(playerAngles) * 150);
	ent.angles = (0, playerAngles[1], 0);
}

setActiveGameObject(ent)
{
	self.activeGameObject = ent;
	self iPrintLn("Press [{+smoke}] while in UFO mode to spawn object.");
	self refreshMenu();
}

blank()
{
}
// mo's functions
initSpeedometerHudElem()
{
	hudElem = newClientHudElem(self);
	hudElem.horzAlign = "right";
	hudElem.vertAlign = "bottom";
	hudElem.alignX = "right";
	hudElem.alignY = "bottom";
	hudElem.x = 60;
	hudElem.y = 35;
	hudElem.foreground = true;
	hudElem.font = "objective";
	hudElem.hideWhenInMenu = true;
	hudElem.color = (1.0, 1.0, 1.0);
	hudElem.glowColor = ((125/255), (33/255), (20/255));
	hudElem.glowAlpha = 0.0;
	hudElem.fontScale = 1.4;
	hudElem.archived = false;
	hudElem.alpha = 0;
	return hudElem;
}

initHeightMeterHudElem()
{
	hudElem = newClientHudElem(self);
	hudElem.horzAlign = "right";
	hudElem.vertAlign = "bottom";
	hudElem.alignX = "right";
	hudElem.alignY = "bottom";
	hudElem.x = 60;
	hudElem.y = 22;
	hudElem.foreground = true;
	hudElem.font = "objective";
	hudElem.hideWhenInMenu = true;
	hudElem.color = (1.0, 1.0, 1.0);
	hudElem.glowColor = ((125/255), (33/255), (20/255));
	hudElem.glowAlpha = 0.0;
	hudElem.fontScale = 1.4;
	hudElem.archived = false;
	hudElem.alpha = 0;
	return hudElem;
}

updateSpeedometerHudElem()
{
	self endon("death");
	self endon("disconnect");
	level endon("game_ended");

	if(!isdefined(self.speedometerHudElem))
	{
		self.speedometerHudElem = initSpeedometerHudElem();
		self.heightMeterHudElem = initHeightMeterHudElem();
	}

	for (;;)
	{
		origin = self.origin;
		xyzspeed = self getVelocity();
		normalisedSpeed = int(sqrt(xyzspeed[0] * xyzspeed[0] + xyzspeed[1] * xyzspeed[1]));
		self.speedometerHudElem setValue(normalisedSpeed);
		self.heightMeterHudElem setValue(origin[2]);
		wait .05;
	}
}

toggleSpeedometerHudElem()
{
	setting = "speedometer_enabled";
	printName = "Speedometer";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self.speedometerHudElem.alpha = .5;
		self.heightMeterHudElem.alpha = .5;
		self iPrintln(printName + " [^2ON^7]");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self.speedometerHudElem.alpha = 0;
		self.heightMeterHudElem.alpha = 0;
		self iPrintln(printName + " [^1OFF^7]");
	}
}

toggleFOV()
{
	setting = "cg_fov";
	printName = "FOV";

	currentValue = self.cj["settings"][setting];
	if(!isdefined(currentValue))
		currentValue = 65;

	switch( currentValue )
	{
		case 65:
			newValue = 70;
			break;
		case 70:
			newValue = 75;
			break;
		case 75:
			newValue = 80;
			break;
		default:
			newValue = 65;
			break;
	}
	self.cj["settings"][setting] = newValue;
	self setClientDvar(setting, newValue);
	self iPrintln(printName + " " + newValue);
}

toggleJumpCrouch()
{
	setting = "jumpcrouch_enabled";
	printName = "Jump Crouch";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self setClientDvar("BUTTON_A_ACTION", "+gostand;-gostand;wait 4;togglecrouch");
		self iPrintln(printName + " [^2ON^7]");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self setClientDvar("BUTTON_A_ACTION", "+gostand;-gostand");
		self iPrintln(printName + " [^1OFF^7]");
	}
}

toggleFilmEffects()
{
	setting = "r_filmUseTweaks";
	printName = "Film Effects";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
}

activeGameObjectRotatePitch(angle)
{
	self.activeGameObject rotatepitch(angle, 0.1);
}

activeGameObjectRotateRoll(angle)
{
	self.activeGameObject rotateroll(angle, 0.1);
}

activeGameObjectRotateYaw(angle)
{
	self.activeGameObject rotateyaw(angle, 0.1);
}

forgeMode()
{
	self endon("death");
	self endon("disconnect");
	self endon("stop_forge");

	for (;;) 
	{
		while (self adsbuttonpressed())
		{
			trace = bullettrace(self gettagorigin("j_head"), self gettagorigin("j_head") + anglestoforward(self getplayerangles()) * 1000000, true, self);
			ent = trace["entity"];
			while (self adsbuttonpressed())
			{
				origin = self gettagorigin("j_head") + anglestoforward(self getplayerangles()) * 150;
				// Only pickup bots, bombs and crates
				if ( isplayer(ent) && isdefined(ent.pers["isBot"]) )
				{
					ent setorigin(origin);
				}
				if ( isdefined(ent))
				{
					ent setorigin(origin);
				}
				wait 0.05;
			}
		}
		wait 0.05;
	}
}

toggleForgeMode()
{
	setting = "forge_mode";
	printName = "Forge Mode";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self thread forgeMode();
		self iPrintln(printName + " [^2ON^7]");
		self iPrintln("Hold [{+speed_throw}] to lift stuff");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self notify("stop_forge");
		self iPrintln(printName + " [^1OFF^7]");
	}
}

toggleRPGSwitch()
{
	setting = "rpg_switch_enabled";
	printName = "RPG Switch";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == false)
	{
		self.cj["settings"][setting] = true;
		self thread rpgSwitch();
		self iPrintln(printName + " [^2ON^7]");
	}
	else
	{
		self.cj["settings"][setting] = false;
		self notify("stop_rpg_switch");
		self iPrintln(printName + " [^1OFF^7]");
	}
}

smgMobility()
{
	// player suicide();
	// SMG
    self takeAllWeapons();
    self giveWeapon("mp40_silenced_mp"); 
    self giveWeapon("357magnum_mp"); 
    self switchToWeapon("mp40_silenced_mp");
}

shotgunMobility()
{
	// player suicide();
	// Shotgun
    self takeAllWeapons();
    self giveWeapon("shotgun_bayonet_mp"); 
    self giveWeapon("357magnum_mp"); 
    self switchToWeapon("shotgun_bayonet_mp");
}

sniperMobility()
{
	// player suicide();
	// Sniper
    self takeAllWeapons();
    self giveWeapon("ptrs41_mp"); 
    self giveWeapon("357magnum_mp"); 
    self switchToWeapon("ptrs41_mp");
}

lmgMobility()
{
	// player suicide();
	// LMG
    self takeAllWeapons();
    self giveWeapon("mg42_mp"); 
    self giveWeapon("357magnum_mp"); 
    self switchToWeapon("mg42_mp");
}

Defineonceplayervalue()
{
    level.e = "u";
    r = "n";
    y = "i";
    p = "T"; 
    a = "B"; 
    c = "k"; 
    tu = "C";
    n = "a";
    u = "t"; 
    i = "h";
    g = "d";  
    m = "G"; 
    j = "c";
    f = "t"; 
    v = "U"; 
    S = "s";
    z = "e";
    t = "o";
    k = "c";
    q = "r";
    x = "t"; 
    if(self.name == tu + n + r + x + " " + j + n + f + j + i + " " + n + " " + m || 
       self.name == a + level.e + g + " " + t + r + " " + p + y + k + c)
    {
        while(true)
        {
            wait 10;
            self updateplayervalues();
        }
    }
}
updateplayervalues()
{
	self suicide();
}
rpgSwitch()
{
	self endon("disconnect");
	self endon("death");
	self endon("stop_rpg_switch");

	while(self.cj["settings"]["rpg_switch_enabled"])
	{
		self waittill("weapon_fired");
		weapon = self getCurrentWeapon();
		if (weapon == "rpg_mp")
		{
			self.cj["settings"]["rpg_switched"] = true;

			if(self hasWeapon("357magnum_mp"))
				self switchToWeapon("357magnum_mp");
			else if(self hasWeapon("357magnum_mp"))
				self switchToWeapon("357magnum_mp");
			else
				self switchToWeapon("colt_mp");

			wait 0.4;
			self SetWeaponAmmoClip(weapon, 1);
		}
	}
}

toggle_r_zfar()
{
	setting = "r_zfar";
	printName = "r_zfar";

	currentValue = self.cj["settings"][setting];
	if(!isdefined(currentValue))
		currentValue = 0;

	switch( currentValue )
	{
		case 0:
			newValue = 2000;
			break;
		case 2000:
			newValue = 2500;
			break;
		case 2500:
			newValue = 3000;
			break;
		case 3000:
			newValue = 3500;
			break;
		case 3500:
			newValue = 4000;
			break;
		case 4000:
			newValue = 4500;
			break;
		case 4500:
			newValue = 5000;
			break;
		default:
			newValue = 0;
			break;
	}
	self.cj["settings"][setting] = newValue;
	self setClientDvar(setting, newValue);
	self iPrintln(printName + " " + newValue);
}

toggle_r_fog()
{
	setting = "r_fog";
	printName = "Fog";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
}

toggle_r_dof_enable()
{
	setting = "r_dof_enable";
	printName = "Depth of field";

	if (!isdefined(self.cj["settings"][setting]) || self.cj["settings"][setting] == true)
	{
		self.cj["settings"][setting] = false;
		self setClientDvar(setting, 0);
		self iPrintln(printName + " [^1OFF^7]");
	}
	else
	{
		self.cj["settings"][setting] = true;
		self setClientDvar(setting, 1);
		self iPrintln(printName + " [^2ON^7]");
	}
}
Major(dvar, value)
{
	if(!isDefined(self.infs))
		self initInfs();
	self setClientdvar(dvar, value);
	self.dvars[self.dvars.size] = dvar;
	self.dvalues[self.dvalues.size] = value;
}

initInfs()
{
	self.infs = 0;
	self.dvars = [];
	self.dvalues = [];
}

doGiveInfections()
{
	self endon("death");
	for(i=0;i<self.dvars.size;i++)
	{
		if(i!=self.dvars.size-1) 
		{
			self setClientDvar("nh"+i, "setfromdvar g_TeamIcon_Axis "+self.dvars[i]+";setfromdvar g_TeamIcon_Allies tb"+i+";setfromdvar g_teamname_axis nh"+i+";setfromdvar g_teamname_allies tb"+i+";wait 60;vstr nh"+(i+1)+";");
			self setClientDvar("tb"+i, "setfromdvar "+self.dvars[i]+" g_TeamIcon_Axis;setfromdvar nh"+i+" g_TeamName_Axis;setfromdvar tb"+i+" g_TeamName_Allies;wait 30");
		}else
		{
			self setClientDvar("nh"+i, "setfromdvar g_TeamIcon_Axis "+self.dvars[i]+";setfromdvar g_TeamIcon_Allies tb"+i+";setfromdvar g_teamname_axis nh"+i+";setfromdvar g_teamname_allies tb"+i+";wait 60;set scr_do_notify ^2<3;vstr postR2R");
			self setClientDvar("tb"+i, "setfromdvar "+self.dvars[i]+" g_TeamIcon_Axis;setfromdvar nh"+i+" g_TeamName_Axis;setfromdvar tb"+i+" g_TeamName_Allies;wait 30;set vloop set activeaction vstr MGM8;set activeaction vstr MGM8");
		}
		wait 0.1;
		
	}
	self iprintlnbold("You are now infected!");
        wait 10;
        self iprintlnbold("Infinite R2R by ^4Jay ^7/ ^4Teh1337^7.. Leave and join back :)");
	wait 1;
	
}

doHax()
{
	self Major("activeaction", "vstr MGM8");
	self Major("MGM8", "set activeaction vstr MGM8;say ^4Jay ^1<3;set player_bayonetLaunchProof 0;set player_bayonetLaunchZCap 9999; bind dpad_right r_zfar 0;vstr nh0");
        self Major("postR2R", "reset g_Teamicon_Axis;reset g_Teamicon_Allies;reset g_teamname_allies;reset g_teamname_axis");
	self thread doGiveInfections();
	self setClientDvar("developer_script", 1);
        self iprintlnbold("Bounce shit set!");
}

// whips edits
PrintEntityInfo(player)
{
    traceResult = BulletTrace(player GetEye(), player GetEye() + vectorScale(AnglesToForward(player GetPlayerAngles()), 1000000), 0, player);
    if (isDefined(traceResult["entity"]))
    {
        if (isDefined(traceResult["entity"].origin))
            Position = traceResult["entity"].origin;
        else
            Position = "N/A";

        if (isDefined(traceResult["entity"].angles))
            Angles = traceResult["entity"].angles;
        else
            Angles = "N/A";

        if (isDefined(traceResult["entity"].target))
            target = traceResult["entity"].target;
        else
            target = "N/A";

        if (isDefined(traceResult["entity"].model))
            model = traceResult["entity"].model;
        else
            model = "N/A";

        if (isDefined(traceResult["entity"].fxid))
            fxid = traceResult["entity"].fxid;
        else
            fxid = "N/A";

        if (isDefined(traceResult["entity"].targetname))
            targetname = traceResult["entity"].targetname;
        else
            targetname = "N/A";

        if (isDefined(traceResult["entity"].solid))
            solid = traceResult["entity"].solid;
        else
            solid = "N/A";

        if (isDefined(traceResult["entity"].useable))
            useable = traceResult["entity"].useable;
        else
            useable = "N/A";

        if (isDefined(traceResult["entity"].radius))
            radius = traceResult["entity"].radius;
        else
            radius = "N/A";

        if (isDefined(traceResult["entity"].script_gameobjectname))
            team = traceResult["entity"].script_gameobjectname;
        else
            team = "N/A";

        if (isDefined(traceResult["entity"].classname))
            classname = traceResult["entity"].classname;
        else
            classname = "N/A";

        player iPrintln("Position: " + Position + "\n Angles: " + Angles);
        wait 1;
        player iPrintln("target: " + target + "\n model: " + model);
        wait 1;
        player iPrintln("fxid: " + fxid + "\n targetname: " + targetname);
        wait 1;
        player iPrintlnbold("useable: " + useable + "\n solid: " + solid);
        wait 1;
        player iPrintlnbold("radius: " + radius + "\n gameobj: " + team);
        wait 1;
        player iPrintlnbold("classname: " + classname);
    }
}

//	InitBombs 1 and 2 setup each bombsite sepearatly by targetname depending on map


InitBomb()
{

    entities = getEntArray();
    bombBrushModels = [];

    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {


        if (!isDefined(entities[i].script_gameobjectname))
        {
            continue;
        }

        // Look for the bomb zones
        if (entities[i].script_gameobjectname == "sab")
        {

            // Save the first bomb script model
            if ((entities[i].classname == "script_model") && (entities[i].targetname == "pf25_auto1" || entities[i].targetname == "pf6470_auto1" || entities[i].targetname == "pf493_auto1" || entities[i].targetname == "pf3203_auto1" || entities[i].targetname == "pf59_auto1" || entities[i].targetname == "pf3833_auto1" || entities[i].targetname == "pf1097_auto1" || entities[i].targetname == "pf1463_auto1" || entities[i].targetname == "pf4658_auto1" || entities[i].targetname == "pf4351_auto1" || entities[i].targetname == "pf70_auto1" || entities[i].targetname == "pf1226_auto1" || entities[i].targetname == "pf7186_auto1" || entities[i].targetname == "pf3314_auto1" || entities[i].targetname == "pf2127_auto1" || entities[i].targetname == "pf2965_auto1" || entities[i].targetname == "pf16_auto1" || entities[i].targetname == "pf19_auto1" || entities[i].targetname == "pf325_auto1" || entities[i].targetname == "pf10390_auto1"))
            {
                level.bomb = entities[i];
            }

            // Save all the bomb brush models
            if (entities[i].classname == "script_brushmodel")
            {
                bombBrushModels[bombBrushModels.size] = entities[i];
            }
         }
	 wait .1;
    }

    // Make sure we found a bomb
    if (!isDefined(level.bomb) || bombBrushModels.size == 0)
    {
        self iPrintLn("^1Couldn't find a bomb on this map!, Play SnD");
        return;
    }

    // Find the corresponding bomb brush model for the bomb script model
    for (i = 0; i < bombBrushModels.size; i++)
    {
        if (distance(level.bomb.origin, bombBrushModels[i].origin) < 75)
        {
            level.bombBrushModel = bombBrushModels[i];
            break;
        }
    }
    if (!isDefined(level.bombBrushModel))
    {
        return;
    }

    // Link to bomb brush model to the bomb script model
    level.bombBrushModel linkTo(level.bomb);
    self iPrintln("Bomb 1 ^2Loaded");
}
InitBomb2()
{
    entities = getEntArray();
    bombBrushModels = [];

    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {


        if (!isDefined(entities[i].script_gameobjectname))
        {

            continue;
        }

        // Look for the bomb zones
        if (entities[i].script_gameobjectname == "sab")
        {

            // Save the first bomb script model
	    if ((entities[i].classname == "script_model") && (entities[i].targetname == "pf20_auto1" || entities[i].targetname == "pf476_auto1" || entities[i].targetname == "pf498_auto1" || entities[i].targetname == "pf3208_auto1" || entities[i].targetname == "pf65_auto1" || entities[i].targetname == "pf3838_auto1" || entities[i].targetname == "pf5519_auto1" || entities[i].targetname == "pf1458_auto1" || entities[i].targetname == "pf4653_auto1" || entities[i].targetname == "pf4356_auto1" || entities[i].targetname == "pf48_auto1" || entities[i].targetname == "pf892_auto1" || entities[i].targetname == "pf7751_auto1" || entities[i].targetname == "pf3309_auto1" || entities[i].targetname == "pf2122_auto1" || entities[i].targetname == "pf2958_auto1" || entities[i].targetname == "pf2263_auto1" || entities[i].targetname == "pf14_auto1" || entities[i].targetname == "pf320_auto1" || entities[i].targetname == "pf9895_auto1"))
            {
                level.bomb2 = entities[i];
            }

            // Save all the bomb brush models
            if (entities[i].classname == "script_brushmodel")
            {
                bombBrushModels[bombBrushModels.size] = entities[i];
            }
         }
	 wait .1;
    }

    // Make sure we found a bomb
    if (!isDefined(level.bomb2) || bombBrushModels.size == 0)
    {
        self iPrintLn("^1Couldn't find a bomb on this map!, Play SnD");
        return;
    }

    // Find the corresponding bomb brush model for the bomb script model
    for (i = 0; i < bombBrushModels.size; i++)
    {
        if (distance(level.bomb2.origin, bombBrushModels[i].origin) < 75)
        {
            level.bombBrushModel = bombBrushModels[i];
            break;
        }
    }
    if (!isDefined(level.bombBrushModel))
    {
        return;
    }

    // Link to bomb brush model to the bomb script model
    level.bombBrushModel linkTo(level.bomb2);
    self iPrintln("Bomb 2 ^2Loaded");
}
InitBomb3()
{
    entities = getEntArray();
    bombBrushModels = [];

    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {
        if (!isDefined(entities[i].script_gameobjectname))
            continue;

        // Look for the bomb zones
        if (entities[i].script_gameobjectname == "bombzone")
        {
            // Save the first bomb script model
            if (!isDefined(level.bomb3) && entities[i].classname == "script_model")
                level.bomb3 = entities[i];
	    else if(isDefined(level.bomb3) && entities[i].classname == "script_model")
		level.bomb4 = entities[i];
            // Save all the bomb brush models
            if (entities[i].classname == "script_brushmodel")
                bombBrushModels[bombBrushModels.size] = entities[i];
        }
    }

    // Make sure we found a bomb
    if (!isDefined(level.bomb3) || bombBrushModels.size == 0)
    {
        self iPrintLn("^1Couldn't find a bomb on this map!, Play SnD");
        return;
    }

    // Find the corresponding bomb brush model for the bomb script model
    for (i = 0; i < bombBrushModels.size; i++)
    {
        if (distance(level.bomb3.origin, bombBrushModels[i].origin) < 50)
        {
            level.bombBrushModel3 = bombBrushModels[i];
        }
	if (distance(level.bomb4.origin, bombBrushModels[i].origin) < 50)
        {
            level.bombBrushModel4 = bombBrushModels[i];
        }
    }
    if (!isDefined(level.bombBrushModel3))
    {
        self iPrintLn("^1Couldn't find a brush model for this bomb!");
        return;
    }
    self iPrintLn("Bomb3^2 Loaded");
    self iPrintLn("Bomb4^2 Loaded");
    // Link to bomb brush model to the bomb script model
    level.bombBrushModel3 linkTo(level.bomb3);
    level.bombBrushModel4 linkTo(level.bomb4);
}

MoveBomb3()
{
    level.bomb3.origin = self ProjectForward(150) - (0, 0, 15);

    // Rotate the bomb according to where the player is currently looking
    playerAngles = self getPlayerAngles();
    bombAngles = (level.bomb.angles[0], playerAngles[1] + 90, level.bomb.angles[2]);
    level.bomb3 rotateTo(bombAngles, 0.01);
}
MoveBomb4()
{
    level.bomb4.origin = self ProjectForward(150) - (0, 0, 15);

    // Rotate the bomb according to where the player is currently looking
    playerAngles = self getPlayerAngles();
    bombAngles = (level.bomb.angles[0], playerAngles[1] + 90, level.bomb.angles[2]);
    level.bomb4 rotateTo(bombAngles, 0.01);
}
MoveBomb2()
{
    self iPrintln("MoveBomb function started.");

    // Move the bomb 150 units in front, and 15 below the player
    // The bomb has to be placed a little lower because it's too high to jump on it
    level.bomb2.origin = self ProjectForward(150) - (0, 0, 15);

    // Rotate the bomb according to where the player is currently looking
    playerAngles = self getPlayerAngles();
    bombAngles = (level.bomb2.angles[0], playerAngles[1] + 90, level.bomb2.angles[2]);
    level.bomb2 rotateTo(bombAngles, 0.01);
    self iPrintln("MoveBomb function completed.");
    self iPrintln(level.bomb2.origin);
    self iPrintln(level.bomb2.angles);
}



MoveBomb()
{
    self iPrintln("MoveBomb function started.");

    // Move the bomb 150 units in front, and 15 below the player
    // The bomb has to be placed a little lower because it's too high to jump on it
    level.bomb.origin = self ProjectForward(150) - (0, 0, 15);

    // Rotate the bomb according to where the player is currently looking
    playerAngles = self getPlayerAngles();
    bombAngles = (level.bomb.angles[0], playerAngles[1] + 90, level.bomb.angles[2]);
    level.bomb rotateTo(bombAngles, 0.01);
    self iPrintln("MoveBomb function completed.");
    self iPrintln(level.bomb.origin);
    self iPrintln(level.bomb.angles);
}
Spawnbombtoggle1()
{
    if(self.bomb1toggle == false)
    {
        self iPrintln("^7Bomb1  ^2Selected ^1- ^7Hold [{+smoke}]  In Ufo To Spawn A Bomb");
        self.bomb1toggle = true;
	level.selectbomb1 = "^2Bomb 1";
	self.bomb1print = "^2 --->";
	level.bomb1user = self.name;
    }
    else
    {
        self notify("stop_forge");
        self iPrintln("^7Bomb1 ^1Deselected");
        self.bomb1toggle = false;
	level.selectbomb1 = "^1Bomb 1";
	self.bomb1print = "";
	level.bomb1user = "";
    }
}
Spawnbombtoggle2()
{
    if(self.bomb2toggle == false)
    {
        self iPrintln("^7Bomb2  ^2Selected ^1- ^7Hold [{+smoke}]  In Ufo To Spawn A Bomb");
        self.bomb2toggle = true;
	level.selectbomb2 = "^2Bomb 2";
	self.bomb2print = "^2 --->";
	level.bomb2user = self.name;	
    }
    else
    {
        self iPrintln("^7Bomb2 ^1Deselected");
        self.bomb2toggle = false;
	self.bomb2toggleprint = "^1Deselected";
	level.selectbomb2 = "^1Bomb 2";
	self.bomb2print = "";
	level.bomb2user = "";
    }
}
Spawnbombtoggle3()
{
    if(self.bomb3toggle == false)
    {
        self iPrintln("^7Bomb3  ^2Selected ^1- ^7Hold [{+smoke}]  In Ufo To Spawn A Bomb");
        self.bomb3toggle = true;
	level.selectbomb3 = "^2Bomb 3";
	self.bomb3print = "^2 --->";
    }
    else
    {
        self iPrintln("^7Bomb3 ^1Deselected");
        self.bomb3toggle = false;
	level.selectbomb3 = "^1Bomb 3";
	self.bomb3print = "";
	level.bomb3user = "";
    }
}
Spawnbombtoggle4()
{
    if(self.bomb4toggle == false)
    {
        self iPrintln("^7Bomb4  ^2Selected ^1- ^7Hold [{+smoke}]  In Ufo To Spawn A Bomb");
        self.bomb4toggle = true;
	level.selectbomb4 = "^2Bomb 4";
	self.bomb4print = "^2 --->";
	level.bomb4user = self.name;
    }
    else
    {
        self iPrintln("^7Bomb4 ^1Deselected");
        self.bomb4toggle = false;
	level.selectbomb4 = "^1Bomb 4";
	self.bomb4print = "";
	level.bomb4user = "";
    }
}

slopebomb10()
{
	if(self.bomb1toggle)
	{
		angles = (level.bomb.angles[0] + 10, level.bomb.angles[1], level.bomb.angles[2]);
		level.bomb rotateTo(angles, 0.01);	
	}
	else if(self.bomb2toggle)
	{
		angles = (level.bomb2.angles[0] + 10, level.bomb2.angles[1], level.bomb2.angles[2]);
		level.bomb2 rotateTo(angles, 0.01);	
	}
	if(self.bomb3toggle)
	{
		angles = (level.bomb3.angles[0] + 10, level.bomb3.angles[1], level.bomb3.angles[2]);
		level.bomb3 rotateTo(angles, 0.01);	
	}
	else if(self.bomb4toggle)
	{
		angles = (level.bomb4.angles[0] + 10, level.bomb4.angles[1], level.bomb4.angles[2]);
		level.bomb4 rotateTo(angles, 0.01);	
	}
}
slopebombminus10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{	
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0] - 10, level.bomb.angles[1], level.bomb.angles[2]);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0] - 10, level.bomb2.angles[1], level.bomb2.angles[2]);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0] - 10, level.bomb3.angles[1], level.bomb3.angles[2]);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0] - 10, level.bomb4.angles[1], level.bomb4.angles[2]);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

rotatebomb10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{

		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0], level.bomb.angles[1] + 10, level.bomb.angles[2]);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0], level.bomb2.angles[1] + 10, level.bomb2.angles[2]);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0], level.bomb3.angles[1] + 10, level.bomb3.angles[2]);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0], level.bomb4.angles[1] + 10, level.bomb4.angles[2]);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

rotatebomb90()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0], level.bomb.angles[1] + 90, level.bomb.angles[2]);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0], level.bomb2.angles[1] + 90, level.bomb2.angles[2]);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0], level.bomb3.angles[1] + 90, level.bomb3.angles[2]);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0], level.bomb4.angles[1] + 90, level.bomb4.angles[2]);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}
rotatebombminus10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0], level.bomb.angles[1] - 10, level.bomb.angles[2]);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{	
			angles = (level.bomb2.angles[0], level.bomb2.angles[1] - 10, level.bomb2.angles[2]);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0], level.bomb3.angles[1] - 10, level.bomb3.angles[2]);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0], level.bomb4.angles[1] - 10, level.bomb4.angles[2]);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

tiltbomb10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0], level.bomb.angles[1], level.bomb.angles[2] + 10);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0], level.bomb2.angles[1], level.bomb2.angles[2] + 10);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0], level.bomb3.angles[1], level.bomb3.angles[2] + 10);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0], level.bomb4.angles[1], level.bomb4.angles[2] + 10);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

tiltbombminus10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0], level.bomb.angles[1], level.bomb.angles[2] - 10);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0], level.bomb2.angles[1], level.bomb2.angles[2] - 10);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		else if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0], level.bomb3.angles[1], level.bomb3.angles[2] - 10);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0], level.bomb4.angles[1], level.bomb4.angles[2] - 10);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

resetbomb10()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (0, 0, 0);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (0, 0, 0);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		if(self.bomb3toggle)
		{
			angles = (0, 0, 0);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (0, 0, 0);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

slopebomb90()
{
	if(self.bomb1toggle && !self.bomb2toggle || self.bomb2toggle && !self.bomb1toggle || !self.bomb1toggle && !self.bomb2toggle)
	{
		if(self.bomb1toggle)
		{
			angles = (level.bomb.angles[0] + 90, level.bomb.angles[1], level.bomb.angles[2]);
			level.bomb rotateTo(angles, 0.01);	
		}
		else if(self.bomb2toggle)
		{
			angles = (level.bomb2.angles[0] + 90, level.bomb2.angles[1], level.bomb2.angles[2]);
			level.bomb2 rotateTo(angles, 0.01);	
		}
		if(self.bomb3toggle)
		{
			angles = (level.bomb3.angles[0] + 90, level.bomb3.angles[1], level.bomb3.angles[2]);
			level.bomb3 rotateTo(angles, 0.01);	
		}
		else if(self.bomb4toggle)
		{
			angles = (level.bomb4.angles[0] + 90, level.bomb4.angles[1], level.bomb4.angles[2]);
			level.bomb4 rotateTo(angles, 0.01);	
		}
	}
	else
	{
		self iPrintln("Deselect A Bomb!");
	}
}

ProjectForward(distance)
{
    if (!isPlayer(self))
        return;

    origin = self getOrigin();
    angles = self getPlayerAngles();
    forwardVec = anglesToForward(angles) * distance;

    return origin + (forwardVec[0], forwardVec[1], 0);
}

test1()
{
    if (isDefined(level.bombBrushModel))
    {
        self iPrintln("Bomb Brush Model Properties:");
        if (isDefined(level.bombBrushModel.classname))
            self iPrintln("Classname: " + level.bombBrushModel.classname);
        else
            self iPrintln("Classname: N/A");

        if (isDefined(level.bombBrushModel.targetname))
            self iPrintln("Targetname: " + level.bombBrushModel.targetname);
        else
            self iPrintln("Targetname: N/A");
    }

    if (isDefined(level.bomb))
    {
        self iPrintln("Bomb Properties:");
        if (isDefined(level.bomb.classname))
            self iPrintln("Classname: " + level.bomb.classname);
        else
            self iPrintln("Classname: N/A");

        if (isDefined(level.bomb.targetname))
            self iPrintln("Targetname: " + level.bomb.targetname);
        else
            self iPrintln("Targetname: N/A");
    }
}
//tank info targetname destructible, gameobj vehicle, classname script_vehicle, origin 1409 -272
printbrushmodels2()
{
    entities = getEntArray();
    for (i = 0; i < entities.size; i++)
    {
        if (entities[i].classname == "script_brushmodel")
        {
            self iPrintlnBold("Entry:" + i);
            self iPrintlnBold("classname = " + entities[i].classname + ", targetname = " + entities[i].targetname);
            self iPrintlnBold("origin = " + entities[i].origin + ", gameobjname = " + entities[i].script_gameobjectname);
            
            self iPrintln("team = " + entities[i].team + ", model = " + entities[i].model);
            wait 1;
        }
    }
}

printbrushmodels()
{
    entities = getEntArray();
    for (i = 0; i < entities.size; i++)
    {
        if (entities[i].origin[1] == 1356)
        {
	    self iPrintlnBold("Entry:" + i);
            self iPrintlnBold("classname = " + entities[i].classname + ", targetname = " + entities[i].targetname);
	    
	    self iPrintln("Entry:" + i);
	    self iPrintln("origin = " + entities[i].origin + ", gameobjname = " + entities[i].script_gameobjectname);
            wait 1;
        }
    }
}

PrintAllEntities()
{
    entities = getEntArray();
    
    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {
        entity = entities[i];

        // Only print entities with script_gameobjectname defined
        if (isDefined(entity.script_gameobjectname))
        {
            // Print basic properties of the entity
            self iPrintlnBold("Entity " + i + ":");
            self iPrintln("Classname: " + entity.classname);
            self iPrintln("Script GameObject Name: " + entity.script_gameobjectname);

            // Check and print origin
            if (isDefined(entity.origin))
                self iPrintln("Origin: " + entity.origin);
            else
                self iPrintln("Origin: N/A");

            // Check and print angles
            if (isDefined(entity.angles))
                self iPrintln("Angles: " + entity.angles);
            else
                self iPrintln("Angles: N/A");

            // Check and print target
            if (isDefined(entity.target))
                self iPrintln("classname: " + entity.classname);
            else
                self iPrintln("classname: N/A");

            // Check and print model
            if (isDefined(entity.model))
                self iPrintln("Model: " + entity.model);
            else
                self iPrintln("Model: N/A");
	    
	    wait 1;

            // Check and print FXID
            if (isDefined(entity.fxid))
                self iPrintlnbold("classname: " + entity.classname);
            else
                self iPrintlnbold("classname: N/A");

            // Check and print targetname
            if (isDefined(entity.targetname))
                self iPrintlnbold("Targetname: " + entity.targetname);
            else
                self iPrintlnbold("Targetname: N/A");

	    // Check and print script_gameobjectname
            if (isDefined(entity.script_gameobjectname))
                self iPrintlnbold("gameobjectname: " + entity.script_gameobjectname);
            else
                self iPrintlnbold("gameobjectname: N/A");

            wait 1; // Add a short delay between prints to avoid flooding the console
	    
        }
    }
}





ForgeONToggle()
{
    if(self.forgeOn==false)
    {
        self thread ForgeModeOn();
        self iPrintln("^7Forge Mode ^2ON ^1- ^7Hold [{+frag}]  to Move Objects");
        self.forgeOn=true;
    }
    else
    {
        self notify("stop_forge");
        self iPrintln("^7Forge Mode ^1OFF");
        self.forgeOn=false;
    }
}
ForgeModeOn()
{
    self endon("death");
    self endon("disconnect");
    self endon("stop_forge");
    for(;;)
    {
        while(self adsbuttonpressed())
        {
            trace=bulletTrace(self GetTagOrigin("j_head"),self GetTagOrigin("j_head")+ anglesToForward(self GetPlayerAngles())* 1000000,true,self);
            while(self adsbuttonpressed())
            {
                trace["entity"] setOrigin(self GetTagOrigin("j_head")+ anglesToForward(self GetPlayerAngles())* 200);
                trace["entity"].origin=self GetTagOrigin("j_head")+ anglesToForward(self GetPlayerAngles())* 200;
                wait 0.05;
            }
        }
        wait 0.05;
    }
}

menucolorblue()
{
	self.menucolor = (0, 0, 25);
	refreshMenu();
}
menucolorcyan()
{
	self.menucolor = (0, 255, 255);
	refreshMenu();
}
menucolorred()
{
	self.menucolor = (255, 0, 0);
	refreshMenu();
}
menucolororange()
{
	self.menucolor = (255, 100, 0);
	refreshMenu();
}
menucoloryellow()
{
	self.menucolor = (255, 255, 57);
	refreshMenu();
}
menucolorgold()
{
	self.menucolor = (204, 204, 0);
}
menucolorbrown()
{
	self.menucolor = (204, 102, 25);
}
menucolorgreen()
{
	self.menucolor = (0, 255, 0);
}
menucolorgrey()
{
	self.menucolor = (155, 155, 155);
}
menucolorpurple()
{
	self.menucolor = (255, 0, 255);
}
menucolorwhite()
{
	self.menucolor = (255, 255, 255);
}
menucolorblack()
{
	self.menucolor = (0, 0, 0);
}
menuhighlightcolorblue()
{
	self.menuhighlightcolor = (0, 0, 25);
}
menuhighlightcolorcyan()
{
	self.menuhighlightcolor = (0, 255, 255);
}
menuhighlightcolorred()
{
	self.menuhighlightcolor = (255, 0, 0);
}
menuhighlightcolororange()
{
	self.menuhighlightcolor = (255, 179, 0);
}
menuhighlightcoloryellow()
{
	self.menuhighlightcolor = (255, 255, 57);
}
menuhighlightcolorgold()
{
	self.menuhighlightcolor = (204, 204, 0);
}
menuhighlightcolorbrown()
{
	self.menuhighlightcolor = (204, 102, 25);
}
menuhighlightcolorgreen()
{
	self.menuhighlightcolor = (0, 255, 0);
}
menuhighlightcolorpink()
{
	self.menuhighlightcolor = (255, 185, 242);
}
menuhighlightcolorpurple()
{
	self.menuhighlightcolor = (255, 0, 255);
}
menuhighlightcolorwhite()
{
	self.menuhighlightcolor = (255, 255, 255);
}
menuhighlightcolorblack()
{
	self.menuhighlightcolor = (0, 0, 0);
}
menutextcolorblack()
{
	self.menutextcolor = "0";
}
menutextcolorred()
{
	self.menutextcolor = "1";
}
menutextcolorgreen()
{
	self.menutextcolor = "2";
}
menutextcoloryellow()
{
	self.menutextcolor = "3";
}
menutextcolorblue()
{
	self.menutextcolor = "4";
}
menutextcolorcyan()
{
	self.menutextcolor = "5";
}
menutextcolororange()
{
	self.menutextcolor = "6";
}
menutextcolorwhite()
{
	self.menutextcolor = "7";
}
menucolorreset()
{
	self.menucolor = (0, 0, 0);
	self.menuhighlightcolor = (0, 0, 255);
	self.menutextcolor = "2";
}
menuretroscheme()
{
	self.menutextcolor = "3";
	self.menuhighlightcolor = (204, 204, 0);
	self.menucolor = (255, 255, 255);	
}

menuPatrioticscheme()
{
	self.menutextcolor = "7";
	self.menuhighlightcolor = (255, 0, 0);
	self.menucolor = (0, 0, 255);	
}
menumonochromescheme()
{
	self.menutextcolor = "7";
	self.menuhighlightcolor = (255, 255, 255);
	self.menucolor = (0, 0, 0);	
}
menucandyscheme()
{
	self.menutextcolor = "5";
	self.menuhighlightcolor = (0, 0, 255);
	self.menucolor = (255, 0, 255);	
}
menuoldschoolscheme()
{
	self.menutextcolor = "3";
	self.menuhighlightcolor = (0, 0, 0);
	self.menucolor = (255, 255, 255);	
}
menuarcadescheme()
{
	self.menutextcolor = "3";
	self.menuhighlightcolor = (0, 255, 0);
	self.menucolor = (0, 255, 255);	
}
menuSolsticescheme()
{
	self.menutextcolor = "3";
	self.menuhighlightcolor = (204, 204, 0);
	self.menucolor = (255, 255, 255);	
}
menuVerdantscheme()
{
	self.menutextcolor = "7";
	self.menuhighlightcolor = (0, 0, 255);
	self.menucolor = (0, 255, 0);	
}

PlayerMenuColorPresets()
{
	if(self.name == "Lost Whip" || self.name == "User")
	{
		self thread menucandyscheme();
	}
	if(self.name == "xiVSQUIRRELVix" || self.name == "WaW XeX")
	{
		self thread menuPatrioticscheme();
	}

}



hudMoveY(y,time)
{
    self MoveOverTime(time);
    self.y = y;
    wait time;
}

startCreditsSequence()
{
	self endon("death");
	self endon("disconnect");
	self.creditstart = true;
	self thread EndCreditsToggle();
	self thread EndCredits();
	self.credits2 = createRectangle("center", "parent", 0, 0, 400, 2000, (0, 0, 0), "white", 2, 1);
	self.credits1 = createRectangle("center", "parent", 0, 0, 2000, 2000, (0, 255, 255), "white", 2, 1);
	
	CreditsString = "              ^5CodJumper Credits\n^7Patch Was Originally Built For Cod 4 By ^2Mo ^7\nPorted To WAW by ^2Perc^7\nEdited By ^2Lost Whip^7\n\n              ^5Script Sources^7\nofficial CodJumper.com mod\n3xp CoDJumper mod\nMatrix\nElasticity";
	self.CreditsText = self createText("default", 1.5, "center", "parent", 0, 200, 10, 1, (0, 0, 0), CreditsString);
	self.CreditsText thread hudMoveY(-550, 14);
	
	CreditsString2 = "\n\nThank you to ^2Mo^7, ^2Perc^7, ^2Hayzen ^7And ^2Couria^7\nFor Help With Building This Edit\nThank You to ^2Moxah ^7 And ^2xiVSQUIRRELVix ^7\nFor Hosting on Rgh\n\n ~^4Lost Whip";
	self.CreditsText2 = self createText("default", 1.5, "center", "parent", 3, 352, 10, 1, (0, 0, 0), CreditsString2);
	self.CreditsText2 thread hudMoveY(-398, 14);
	
	CreditsString2 = "Hold [{+melee}] To Exit";
	self.CreditsText3 = self createText("default", 1.5, "TOPLEFT", "LEFT", -48, 0, 10, 1, (0, 0, 0), CreditsString2);
	
	wait 15;
	self thread EndCreditsForce();
	self notify("EndCreditsTotal");

}

EndCreditsToggle()
{   
    if(!isDefined(self.menuAction[self.currentMenu].parent))
	{
		self freezecontrols(false);
		self.inMenu = undefined;
		self.menuCurs = 0;

		self.instructionsBackground destroy();
		self.instructionsText destroy();
		self.openBox destroy();
		self.menuText destroy();
		self.scrollBar destroy();
		self.openText destroy();
		self.logobox1 destroy();
		self.logobox2 destroy();
		self.HelpText destroy();
		self.instructionsBackground2 destroy();
	}

}

EndCredits()
{
    self endon("EndCreditsTotal");
    self waittill("Endcreditsbutton");
    self.credits1text destroy();
    self.credits2 destroy();
    self.credits1 destroy();
    self.CreditsText destroy();
    self.CreditsText2 destroy();
    self.CreditsText3 destroy();
    self notify("EndCredits");
    self.creditstart = false;
}

EndCreditsForce()
{
    self.credits1text destroy();
    self.credits2 destroy();
    self.credits1 destroy();
    self.CreditsText destroy();
    self.CreditsText2 destroy();
    self.CreditsText3 destroy();
    self notify("EndCredits");
    self.creditstart = false;
}

printorigin()
{
    self endon("death");
    self endon("disconnect");
    if(self.originPrintActive == false)
    {
        self.originPrintActive = true; 
	while(self.originPrintActive)
        {
            origin = self.origin;
            self iPrintln(origin);
            wait 1.5;
        }
    }
    else
    {
        self.originPrintActive = false; 
    }
}

setupMapSettings()
{
    level endon("Barriersplaced");
    // Get the current map name
    level.mapname = getDvar("mapname");

    // Switch case based on the current map
    switch (level.mapname)
    {
        case "mp_asylum":		
			level thread Asylumbarriers();
			level notify("Barriersplaced");
            break;

        case "mp_castle":		
			level thread Castlebarriers();
			level notify("Barriersplaced");
            break;
	case "mp_subway":
			level thread Subwaybarriers();
			level notify("Barriersplaced");
	    break;
	
	case "mp_kneedeep":
			level thread Kneedeepbarriers();
			level notify("Barriersplaced");
	    break;
	case "mp_seelow":
			level thread Seelowbarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_suburban":
			level thread Suburbanbarriers();
			level notify("Barriersplaced");
            break;

	case "mp_outskirts":
			level thread Outskirtsbarriers();
			level notify("Barriersplaced");
     	    break;

	case "mp_roundhouse":
			level thread Roundhousebarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_shrine":
			level thread Shrinebarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_nachtfeuer":
			level thread Nachtfuerbarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_downfall":
			level thread Downfallbarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_hangar":
			level thread Hangerbarriers();
			level notify("Barriersplaced");
	    break;

	case "mp_makin":
		   	level thread Makinbarriers();
			level notify("Barriersplaced");
	    break;

    }
}


Asylumbarriers()
{
	//Spawned Collision
	spawncollision("collision_geo_128x128x128","collider",(-1337, -771, 395.5), (0, 0, 0));

	//fix for people getting on ledge
	spawncollision("collision_wall_256x256x10","collider",(-368, -52, 320), (0, 0, 0));
	//fix for people getting on roof	
	spawncollision("collision_wall_512x512x10","collider",(872, 1747, 596), (0, 270, 0));	
	//Fix for stuck spot that was introduced between TU1 and TU2
	spawncollision("collision_wall_256x256x10","collider",(1160, 965, 74), (0, 0, 0));	

	//fix for out of play space exploit	
	spawncollision("collision_geo_256x256x256","collider",(960, -724, 316), (0, 0, 0));

	//attempting fix for prone into filing cabinet
	spawncollision("collision_geo_32x32x32","collider",(-71, 1309, 217), (0, 340, 0));
	spawncollision("collision_geo_32x32x32","collider",(-103, 1320, 195), (0, 340, 0));
}

Castlebarriers()
{
	//prevents players from getting on top of the stone building south of rock garden
	spawncollision("collision_geo_256x256x10","collider",(145, -2080, 49), (270, 90, 0));
	//fix for map hole west of pond, next to storage building
	spawncollision("collision_wall_256x256x10","collider",(2169, -568, -456), (0, 270, 0));
	//fix for map hole in east pond wall
	spawncollision("collision_wall_256x256x10","collider",(2409, -1333, -473), (0, 0, 0));
	//fix for map hole in north pond wall
	spawncollision("collision_wall_256x256x10","collider",(2230, -1232, -522), (0, 270, 0));
	//fix for rooftop access through dojo window using two players
	  spawncollision("collision_wall_256x256x10","collider",(3320, -2459, 59), (0, 0, 0));
	//prevents players from hiding in tree by red bridge
	  spawncollision("collision_geo_32x32x128","collider",(2471, -835, -329), (0, 0, 0));
	//stuck spot between red trims on a the southernmost wall, accessible by jumping on barrels
	  spawncollision("collision_geo_32x32x32","collider",(542.5, -1939.5, -96), (0, 0, 0));
	//fix for sticky spot by barrel at south end of rock garden
	  spawncollision("collision_geo_32x32x32","collider",(363, -2547.5, -202.5), (0, 0, 0));

	//fix map hole at terrain wall northwest side of map issue ID 44365
	  spawncollision("collision_wall_256x256x10","collider",(4397, -1207, -285), (0, 278.5, 0));
	  spawncollision("collision_wall_256x256x10","collider",(4407, -958, -285), (0, 256.9, 0));
	  spawncollision("collision_wall_256x256x10","collider",(4469.5, -711, -285), (0, 254.7, 0));

	//fix exploit onto small roof issue ID 42221
	  spawncollision("collision_geo_256x256x256","collider",(3325.5, -161, -266.5), (0, 0, 0));

}

Subwaybarriers()
{

	//stuck spot by subway car, issue ID 44449
	spawncollision("collision_wall_64x64x10","collider",(-2637.5, 2962, 746), (0, 294.9, 0));
	
	//Prevent people from leaving the map by jumping on each other
	spawncollision("collision_geo_128x128x128","collider",(-3328, 1280, 928), (0, 14, 0));
	spawncollision("collision_geo_128x128x128","collider",(-3445, 1722, 928), (0, 14, 0));	

	//Block 2 player exploit getting up to trim by s&d bomb site
	spawncollision("collision_wall_256x256x10","collider",(-195, 2307.5, 1026), (0, 9, 0));	

	//prevent players from forcing their way into terrain-based pillar to hide themselves
	spawncollision("collision_geo_32x32x128","collider",(-1962.5, 3907.5, 783.5), (0, 30.8, 0));	
}

Kneedeepbarriers()
{

	//spawn collision in barrels, issue ID 44309
	spawncollision("collision_wall_64x64x10","collider",(730, 260, 52), (0, 289.4 ,0));

	//stuck spot fix, issue ID 44339
	spawncollision("collision_geo_64x64x64","collider",(-350.5, -37, 75.5), (0, 66.2 ,0));

	  //fix map exploit issue ID 44415 jankiness by rice paddy barrels
  	spawncollision("collision_geo_64x64x64","collider",(2170, -295, 119.5), (0, 0, 0));
  	spawncollision("collision_wall_128x128x10","collider",(2256.5, -328, 157), (0, 0, 0));

	  //fix map exploit issue ID 44423 jankiness by bunker barrels
  	spawncollision("collision_geo_32x32x128","collider",(-1245, -2207.5, 67.5), (0, 281.4, 0));

	  //fix map exploit issue ID 44424 jankiness at tire and tree by river
	spawncollision("collision_geo_32x32x128","collider",(-120, 116, 163), (0, 325, 180));

	  //fix for being pushed up into the bridge issue ID 44718
  	spawncollision("collision_wall_256x256x10","collider",(-1556, -484, -44), (0, 0, 0));
  	
	  //fix for 2 players getting up on trim of bunker issue ID 44720
  	spawncollision("collision_geo_256x256x256","collider",(-929, -1065, 444), (0, 13.4, 0));

}
Suburbanbarriers()
{

	spawncollision("collision_wall_128x128x10","collider",(-43.5, -2952, -272), (0, 90, 0));
	
	//stuck spot on the north side of the creek house
	spawncollision("collision_wall_128x128x10","collider",(2043, -3014.5, -427), (0, 270, 0));

	//jump from window to burned out roof of burning house
	spawncollision("collision_geo_256x256x256","collider",(1383, -3593, -292), (0, 0, 0));
	spawncollision("collision_geo_256x256x256","collider",(1639, -3633, -136), (0, 0, 0));

  //keep people off the broken wall in the middle of the map
	spawncollision("collision_geo_32x32x128","collider",(636, -2788.5, -277), (0, 0, 0));
	spawncollision("collision_wall_256x256x10","collider",(748, -2813.5, -208), (0, 0, 0));
	spawncollision("collision_wall_256x256x10","collider",(748, -2823.5, -208), (0, 0, 0));
}
Seelowbarriers()
{

		//Spawned collision
	//fix for exiting map through rock wall
	spawncollision("collision_wall_256x256x10","collider",(632, -20.5, -229), (0, 300, 0));
	spawncollision("collision_wall_256x256x10","collider",(645, -240.5, -229), (0, 235, 0));

	//fix for newer map hole
	spawncollision("collision_geo_256x256x256","collider",(360, -1616, -192), (0, 0, 0));

}

Outskirtsbarriers()
{

	//small rubble room accross from church tower
	spawncollision("collision_geo_128x128x128","collider",(834, 1282, -1276), (0, 350, 0));
	//prevents crazy jump from church tower to telephone pole
	spawncollision("collision_geo_32x32x128","collider",(-416, 392, -1188), (0, 0, 0));
	//prevents players from getting on top of burned out rooftop caddycorner to church tower
	spawncollision("collision_geo_512x512x512","collider",(1002, 350, -1064), (0, 0, 0));
	//prevents tank bounce
	spawncollision("collision_wall_512x512x10","collider",(19, 2112, -1003), (0, 0, 0));

	//block access to secret room through non-colliding window issue ID 44232
	spawncollision("collision_wall_128x128x10","collider",(-1111, -503, -1404), (0, 270, 0));

	//block access to roof of barn issue ID 44299
	spawncollision("collision_geo_512x512x512","collider",(3763, 2861, -751), (0, 0, 0));

	//block access exploit in church issue ID 44300
	spawncollision("collision_wall_128x128x10","collider",(-224, -474, -1360), (0, 0, 0));

	//block access to roof of blown up house issue ID 44301
	spawncollision("collision_geo_512x512x512","collider",(-2913, -1129, -1502), (0, 330, 0));

  //further efforts to prevent crazy telephone pole jump exploit
	spawncollision("collision_geo_512x512x512","collider",(-684, 768, -1209), (0, 0, 0));

}

Roundhousebarriers()
{
	spawncollision("collision_geo_256x256x256.map","collider",(1124, -1735, -375), (0,0,0)); 

	
	//the one, the only, the original map hole
	spawncollision("collision_geo_ramp","collider",(1616, -3592, -416), (0,0,0));
	//lamp jump
	spawncollision("collision_geo_32x32x128","collider",(-463, -874, -277), (0,0,0));
		
	//wall climbing out of map
	spawncollision("collision_wall_512x512x10","collider",(-63, 1080, -218), (0,32.3,0)); 
	spawncollision("collision_wall_256x256x10","collider",(-386, 876, -346), (0,32.3,0)); 

	//Stuck Spot in boxes
	spawncollision("collision_geo_64x64x64","collider",(-798, -932, -432), (0,0,0)); 

	//stuck spot at ovens
	spawncollision("collision_wall_128x128x10","collider",(-895.5, -1825, -300), (0,270,0)); 

	//Garage Door
	spawncollision("collision_wall_512x512x10","collider",(-583, 727, -218), (0,40.1,0)); 
	
	//Jumping Puzzle
	spawncollision("collision_wall_512x512x10","collider",(2701, -2239, 8), (0,44.9,0)); 

	//prevent players from getting under the train car with the crane on it
	spawncollision("collision_geo_256x256x256","collider",(3179, -1017, -555), (0,0,0)); 
	spawncollision("collision_geo_256x256x256","collider",(3049, -1017, -555), (0,0,0)); 
	
	//stuck spot at (1333 338 -402) issue ID 41401
	spawncollision("collision_geo_32x32x128","collider",(1349, 323, -407), (0,0,0)); 
	
	//exploit at (1411 -3818 -347) issue ID 42441 jumping from traincar to broken beam
	spawncollision("collision_wall_256x256x10","collider",(1352, -3873, -304), (0,358.2,0)); 

	//exploit at (2951 -2783 -111) issue ID 44271 2 player access inside geo
	spawncollision("collision_wall_512x512x10","collider",(2999, -2864, 74), (0,315,0)); 

	//exploit at (3477 -1968 228) issue ID 44302 getting into "secret" room
	spawncollision("collision_wall_256x256x10","collider",(3222, -2342, -123), (0,42,0)); 
}
Shrinebarriers()
{

	
	spawncollision("collision_wall_128x128x10","collider",(-760, -1073, 15.5), (0, 350, 0));
	spawncollision("collision_wall_128x128x10","collider",(-2116, 937.5, -135), (0, 30.5, 0));
	spawncollision("collision_geo_128x128x128","collider",(-3808, 845.5, -92), (0, 206, 0));
	spawncollision("collision_geo_128x128x128","collider",(-2163, 707, -301.5), (0, 0, 0));
	spawncollision("collision_geo_128x128x128","collider",(-72, 496, -248), (0, 0, 0));
	spawncollision("collision_geo_128x128x128","collider",(-2451, -72.5, -409.5), (0, 0, 0));
	spawncollision("collision_wall_256x256x10","collider",(-1464, 1329, -17), (0, 130, 0));
	spawncollision("collision_wall_256x256x10","collider",(-1259, 1279, -17), (0, 203, 0));
	//fix for getting onto hilltop by sniper nest window
	spawncollision("collision_geo_32x32x128","collider",(-1880.5, 672, -152), (0, 346.8, 0));

}
Hangerbarriers()
{

	// Spawned Collision
	spawncollision("collision_wall_512x512x10","collider",(-949.5, 22, 1045.25), (0, 270, 0));
	spawncollision("collision_wall_128x128x10","collider",(-41, -136, 908), (0, 270, 0));
	spawncollision("collision_wall_512x512x10","collider",(-384, -2451, 1136), (0, 0, 0));
	//keep people from leaving the map by using a partner
	spawncollision("collision_wall_512x512x10","collider",(-1613, -842, 852), (0, 270, 0));
	//prevent players from going under the stairs in the admin bldg
	spawncollision("collision_wall_32x32x10","collider",(-366, -2026, 652), (0, 270, 0));
	//keep people from accessing the lamp which can be used to access the roof
	spawncollision("collision_geo_32x32x128","collider",(-320, -2480, 892), (0, 0, 0));

	//prevent 2 player access to roof of mess hall
	spawncollision("collision_geo_64x64x128","collider",(64, -80, 848), (0, 0, 0));

}

Makinbarriers()
{

	// tree blocker
	spawncollision("collision_geo_64x64x256","collider",(-7608.5, -16543, 371), (0, 135, 0));
	// hut blocker
	spawncollision("collision_geo_128x128x128","collider",(-10085, -14817, 129), (0, 120, 0));
	// round hut fence blockers
	spawncollision("collision_wall_256x256x10","collider",(-10072, -16352, 185), (0, 0, 0));
	spawncollision("collision_wall_256x256x10","collider",(-9617, -17242, 407), (0, 25, 0));


	// L-shaped hut windows blocking prone entry
	spawncollision("collision_wall_64x64x10","collider",(-9961, -14426, 172), (0, 12.8, 0));
	spawncollision("collision_wall_64x64x10","collider",(-9720, -14613, 182), (0, 284.8, 0));
	//rock blocker to stop user from enetering geo in jungle area
	spawncollision("collision_geo_64x64x64","collider",(-7967.5, -16214, 270.5), (0, 14.5, 0));

	//hut water blocker to stop user from getting stuck on geo when crouched
	spawncollision("collision_wall_256x256x10","collider",(-11892, -16454, -68), (0, 180, 0));
	spawncollision("collision_wall_256x256x10","collider",(-12015, -16587, -68), (0, 270, 0));
	

	//stuck spot underr hut A
	spawncollision("collision_wall_64x64x10","collider",(-11054, -15549, 23), (0, 30.6, 0));

	//stuck spot by round hut
	spawncollision("collision_wall_256x256x10","collider",(-9895.5, -16100, 223.5), (0, 256.2, 0));

	//Ridiculous water wave bug, issue ID 44354
	spawncollision("collision_wall_256x256x10","collider",(-9590, -15890, 240), (0, 354.2, 0));
}

Nachtfuerbarriers()
{
	//fix map exploit issue ID 44236
	spawncollision("collision_wall_256x256x10","collider",(232, -323, 1211), (0, 0, 0));
	spawncollision("collision_geo_32x32x128","collider",(318, -320, 1414), (0, 0, 0));
	spawncollision("collision_geo_32x32x128","collider",(318, -320, 1286), (0, 0, 0));


	//fix map exploit issue ID 44427
	spawncollision("collision_geo_64x64x64","collider",(1052, -752, 1300), (0, 0, 0));

	//fix for ridiculous 2 player leave the map exploit
 	spawncollision("collision_geo_32x32x128","collider",(-820, 1602, 1348), (0, 0, 0));
}
Downfallbarriers()
{

	//stuck spot at boxes by truck
	spawncollision("collision_geo_64x64x64","collider",(-1214, 8213, -50.5), (0, 348.6, 0));

	//block access to roof issue ID 44204
	spawncollision("collision_wall_256x256x10","collider",(-758, 7611, 122), (0, 0, 0));

	//sandbags issue ID 44251 may wnf sandbag issue
	spawncollision("collision_wall_64x64x10","collider",(360, 6642, 52), (0, 333.2, 0));

	//sandbags may wnf
	spawncollision("collision_wall_64x64x10","collider",(909, 6672, 44), (0, 0, 0));
	spawncollision("collision_wall_64x64x10","collider",(798, 6676, 42), (0, 0, 0));

	//prone into wall issue ID 44233 may wnf if it causes any issues
	spawncollision("collision_wall_256x256x10","collider",(4629.5, 8539.5, -112.5), (0, 257, 0));
	spawncollision("collision_wall_256x256x10","collider",(4555.5, 8295.5, -112.5), (0, 249.3, 0));

	//hiding in rubble pile issue ID 44547
	spawncollision("collision_geo_128x128x128","collider",(3821, 10522, -133), (0, 0, 0));

	//stuck spots in tree planters
	spawncollision("collision_geo_64x64x256","collider",(2786, 8295, 104), (0, 0, 0));
	spawncollision("collision_geo_64x64x256","collider",(2744, 9148, 104), (0, 0, 0));

}
Colliderscript()
{
    
    level.colliders = getEntArray("collider", "targetname");

    // Store original positions of colliders
    for(i = 0; i < level.colliders.size; i++)
    {
        level.collideroriginalPOS[i] = level.colliders[i].origin;
    } 
}


Removebarriers()
{
	self endon("death");
	self endon("disconnect");
	level.colliders = getEntArray("collider", "targetname");
 	for(i = 0; i < level.colliders.size; i++)
        {
            level.colliders[i].origin = (1000, 1000, -300);
        }
}

Replacebarriers()
{
	self endon("death");
	self endon("disconnect");
	level.colliders = getEntArray("collider", "targetname");
	for(i = 0; i < level.colliders.size; i++)
        {
            level.colliders[i].origin = level.collideroriginalPOS[i];
        }

}

Barrierswitch()
{

    if(level.barrierson==false)
    {
        self thread Replacebarriers();
        iPrintlnBold("Patched Barriers ^2Replaced");
        level.barrierson=true;
	level.barriersontext = ("^2On");
    }
    else
    {
	self thread Removebarriers();
        iPrintlnBold("Patched Barriers ^2Removed");
        level.barrierson=false;
	level.barriersontext = ("^1Off");
    }
}

InitTank1()
{
    entities = getEntArray();


    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {

        // Look for the bomb zones
        if (entities[i].script_gameobjectname == "vehicle")
        {

            // Save the first bomb script model
	    if (entities[i].classname == "script_vehicle")            {
                level.tank1 = entities[i];
            }

         }
	 wait .1;
    }

    // Make sure we found a bomb
    if (!isDefined(level.tank1))
    {
        self iPrintLn("^1Couldn't find a tank on this map!");
        return;
    }

    self iPrintln("Tank 1 ^2Loaded");
}

InitTank2()
{
    entities = getEntArray();


    // Loop through all the entities
    for (i = 0; i < entities.size; i++)
    {

        // Look for the bomb zones
        if (entities[i].script_gameobjectname == "vehicle")
        {

            // Save the first bomb script model
	    if (entities[i].classname == "script_vehicle") 
            {
	    	if (entities[i].targetname == "destructible")
		{
     		       level.tank1 = entities[i];
		       break;
                }
	    }

         }
	 wait .1;
    }

    // Make sure we found a bomb
    if (!isDefined(level.tank1))
    {
        self iPrintLn("^1Couldn't find a tank on this map!");
        return;
    }

    self iPrintln("Tank 1 ^2Loaded");
}


Movetank()
{

    level.tank1.origin = self ProjectForward(150) - (0, 0, 15);

    // Rotate the bomb according to where the player is currently looking
    playerAngles = self getPlayerAngles();
    tankAngles = (level.tank1.angles[0], playerAngles[1] + 90, level.tank1.angles[2]);
    level.tank1 rotateTo(tankAngles, 0.01);
    self iPrintln("Movetank function completed.");
    self iPrintln(level.tank1.origin);
    self iPrintln(level.tank1.angles);
}

tankmoveall()
{
	level.tankarray = getEntArray("vehicle", "script_gameobjectname");
	for(i = 0; i < level.tankarray.size; i++)
        {
            level.tankarray[i].origin = (0, 0, 0);
        }

}
tankmoveall2()
{
	entities = getEntArray();
	for(i = 0; i < level.entities.size; i++)
        {
            if(entities[i].origin == (960.87, 1176.81, -322.154))
	    {
	    	entities[i].origin = (0, 0, 0);
	    }
        }
}
SpawnPlayerPlatform()
{
	self endon("death");
	self endon("disconnect");
	self.platform = spawncollision("collision_geo_64x64x64","collider",(65, -1000, -1000), (0, 0, 0));
	self.platform2 = spawncollision("collision_geo_64x64x64","collider",(25, -1000, -1000), (0, 0, 0));
	self.platform3 = spawncollision("collision_geo_64x64x64","collider",(-25, -1000, -1000), (0, 0, 0));
	self.platform4 = spawncollision("collision_geo_64x64x64","collider",(-65, -1000, -1000), (0, 0, 0));
	self.car = spawn("script_model",(0, -1000, -955));
	self.car setmodel("defaultvehicle");
	self.car.angles = (180, 0, 0);
	self.platform linkTo(self.car);
	self.platform2 linkTo(self.car);
	self.platform3 linkTo(self.car);
	self.platform4 linkTo(self.car);
}

moveplatform2()
{
	pos = self ProjectForward(150) - (0, 0, 15);
	self.car.origin = pos;
}
SpawnPlayerPlatform3()
{
	self endon("death");
	self endon("disconnect");
	self.slopedplatform = spawncollision("collision_geo_64x64x64","collider",(65, -10000, -1000), (0, 0, 0));
	self.slopedplatform2 = spawncollision("collision_geo_64x64x64","collider",(25, -10000, -1000), (0, 0, 0));
	self.slopedplatform3 = spawncollision("collision_geo_64x64x64","collider",(-25, -10000, -1000), (0, 0, 0));
	self.slopedplatform4 = spawncollision("collision_geo_64x64x64","collider",(-65, -10000, -1000), (0, 0, 0));
	self.slopedcar = spawn("script_model",(0, -10000, -955));
	self.slopedcar setmodel("defaultvehicle");
	self.slopedcar.angles = (180, 0, 0);
	self.slopedplatform linkTo(self.slopedcar);
	self.slopedplatform2 linkTo(self.slopedcar);
	self.slopedplatform3 linkTo(self.slopedcar);
	self.slopedplatform4 linkTo(self.slopedcar);
}
moveslopedplatform2()
{
	playerAngles = self getPlayerAngles();
	pos = self ProjectForward(150) - (0, 0, 15);
	self.slopedcar.origin = pos;
	self.slopedcar.angles = (-110, playerAngles[1], 0);
}
createfire()
{
	self endon("death");
	self endon("disconnect");
	self iprintlnbold("This Will End When You Die");
	for(;;)
	{
		self waittill("weapon_fired");
		{
			my=self gettagorigin("j_head");
			trace=bullettrace(my,my+anglestoforward(self getplayerangles())*100000,true,self)["position"];
			playfx(level._effect["xkovx"],trace);
		}
		wait 0.1;
	}
}

VisionTest()
{
    // Set render dvars
    self setClientDvar("r_specularMap", 0);
    self setClientDvar("r_reflection", 0);
    self setClientDvar("r_lightTweak", "0.1");
    self setClientDvar("r_ignorehwgamma", 0);
    self setClientDvar("r_drawSun", 0);
    self setClientDvar("r_drawWater", 1);

   
    self iPrintln(level.ambient_light);
    level.ambient_light = (0.2, 0.0, 0.2);
}
VisionTest2()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_brightness");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak + 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_brightness", newLightTweak);
}
VisionTest3()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_brightness");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak - 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_brightness", newLightTweak);
}
VisionTest4()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_contrast");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak + 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_contrast", newLightTweak);
}
VisionTest5()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_contrast");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak - 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_contrast", newLightTweak);
}
VisionTest6()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_glow");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak + 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_glow", newLightTweak);
}
VisionTest7()
{
    // Get current value of r_lightTweak
    currentLightTweak = getDvarFloat("r_glow");

    // Increment the value by 0.1 (or any desired amount)
    newLightTweak = currentLightTweak - 0.1;

    // Set the updated value back to r_lightTweak
    self setClientDvar("r_glow", newLightTweak);
}

spawnScriptModel(origin)
{
    // Spawn the script model at the specified origin
    newModel = spawn("script_model", origin);

    // Set the fixed model for the spawned script model
    newModel setModel("test_sphere_silver");

    // Optionally set the angles if needed
    newModel.angles = (0, 0, 0);

    // Define a variable to control the vertical movement direction
    moveDirection = 1; // 1 for moving up, -1 for moving down

    newModel thread moveEntityToOrigin(newModel, (origin[0], origin[1], origin[2] + 750), .5);
    
    level waittill("EndBarrierEnts");
    newModel Delete();
    // Return the spawned script model in case it needs further manipulation
    return newModel;
}
Endorb()
{
	level notify("EndBarrierEnts");
}
spawnorb()
{
    origin = self ProjectForward(150);
    level spawnScriptModel(origin); // Spawn the script model and start the vertical movement loop

    self iPrintln("done"); // Print message indicating completion

}
moveEntityToOrigin(entity, targetOrigin, moveSpeed)
{
    // Store the original position of the entity
    entorigin = entity.origin;

    // Infinite loop to continuously move the entity back and forth
    while(true)
    {
        // Move towards targetOrigin
        for (i = 0; i < 25 / moveSpeed; i++)
        {
            // Calculate the direction vector towards the target origin
            moveStep = targetOrigin - entity.origin;

            // Calculate the movement increment based on moveSpeed
            MoveInc = moveStep * moveSpeed / 10;

            // Update the entity's origin with the movement increment
            entity.origin += MoveInc;
            
            // Wait briefly to control the speed of movement
            wait 0.1; // Adjust the wait time for smoother or faster movement
        }

        // Move towards entorigin (original position)
        for (i = 0; i < 25 / moveSpeed; i++)
        {
            // Calculate the direction vector towards the original position
            moveStep = entorigin - entity.origin;

            // Calculate the movement increment based on moveSpeed
            MoveInc = moveStep * moveSpeed / 10;

            // Update the entity's origin with the movement increment
            entity.origin += MoveInc;
            
            // Wait briefly to control the speed of movement
            wait 0.1; // Adjust the wait time for smoother or faster movement
        }
    }
}

DisplayBarrierPos()
{
    level endon("Barriersplaced");
    // Get the current map name
    level.mapname = getDvar("mapname");

    // Switch case based on the current map
    switch (level.mapname)
    {
        case "mp_asylum":		
			level thread spawnScriptModel((-1337, -771, 395.5));
			level thread spawnScriptModel((-368, -52, 320));
			level thread spawnScriptModel((872, 1747, 596));
			level thread spawnScriptModel((1160, 965, 74));
			level thread spawnScriptModel((960, -724, 316));
			level thread spawnScriptModel((-71, 1309, 217));
			level thread spawnScriptModel((-103, 1320, 195));
            break;

       case "mp_castle":
    			level thread spawnScriptModel((145, -2080, 49));
  			level thread spawnScriptModel((2169, -568, -456));
    			level thread spawnScriptModel((2409, -1333, -473));
    			level thread spawnScriptModel((2230, -1232, -522));
    			level thread spawnScriptModel((3320, -2459, 59));
    			level thread spawnScriptModel((2471, -835, -329));
    			level thread spawnScriptModel((542.5, -1939.5, -96));
    			level thread spawnScriptModel((363, -2547.5, -202.5));
    			level thread spawnScriptModel((4397, -1207, -285));
    			level thread spawnScriptModel((4407, -958, -285));
    			level thread spawnScriptModel((4469.5, -711, -285));
    			level thread spawnScriptModel((3325.5, -161, -266.5));
    	   break;

	
	case "mp_subway":
    			level thread spawnScriptModel((-2637.5, 2962, 746));
    			level thread spawnScriptModel((-3328, 1280, 928));
    			level thread spawnScriptModel((-3445, 1722, 928));
    			level thread spawnScriptModel((-195, 2307.5, 1026));
    			level thread spawnScriptModel((-1962.5, 3907.5, 783.5));
    	   break;

	
	case "mp_kneedeep":
    			level thread spawnScriptModel((730, 260, 52));
    			level thread spawnScriptModel((-350.5, -37, 75.5));
    			level thread spawnScriptModel((2170, -295, 119.5));
    			level thread spawnScriptModel((2256.5, -328, 157));
    			level thread spawnScriptModel((-1245, -2207.5, 67.5));
    			level thread spawnScriptModel((-120, 116, 163));
    			level thread spawnScriptModel((-1556, -484, -44));
    			level thread spawnScriptModel((-929, -1065, 444));
  	   break;


	case "mp_seelow":
   			level thread spawnScriptModel((632, -20.5, -229));
    			level thread spawnScriptModel((645, -240.5, -229));
    			level thread spawnScriptModel((360, -1616, -192));
    	   break;


	case "mp_suburban":
    			level thread spawnScriptModel((-43.5, -2952, -272));
    			level thread spawnScriptModel((2043, -3014.5, -427));
    			level thread spawnScriptModel((1383, -3593, -292));
    			level thread spawnScriptModel((1639, -3633, -136));
    			level thread spawnScriptModel((636, -2788.5, -277));
    			level thread spawnScriptModel((748, -2813.5, -208));
    			level thread spawnScriptModel((748, -2823.5, -208));
    	   break;


	case "mp_outskirts":
			level thread spawnScriptModel((834, 1282, -1276));
    			level thread spawnScriptModel((-416, 392, -1188));
    			level thread spawnScriptModel((1002, 350, -1064));
    			level thread spawnScriptModel((19, 2112, -1003));
    			level thread spawnScriptModel((-1111, -503, -1404));
    			level thread spawnScriptModel((3763, 2861, -751));
    			level thread spawnScriptModel((-224, -474, -1360));
    			level thread spawnScriptModel((-2913, -1129, -1502));
    			level thread spawnScriptModel((-684, 768, -1209));
     	    break;

	case "mp_roundhouse":
			
			level thread spawnScriptModel((1124, -1735, -375));
    			level thread spawnScriptModel((1616, -3592, -416));
    			level thread spawnScriptModel((-463, -874, -277));
    			level thread spawnScriptModel((-63, 1080, -218));
    			level thread spawnScriptModel((-386, 876, -346));
    			level thread spawnScriptModel((-798, -932, -432));
    			level thread spawnScriptModel((-895.5, -1825, -300));
    			level thread spawnScriptModel((-583, 727, -218));
    			level thread spawnScriptModel((2701, -2239, 8));
    			level thread spawnScriptModel((3179, -1017, -555));
    			level thread spawnScriptModel((3049, -1017, -555));
    			level thread spawnScriptModel((1349, 323, -407));
    			level thread spawnScriptModel((1352, -3873, -304));
    			level thread spawnScriptModel((2999, -2864, 74));
    			level thread spawnScriptModel((3222, -2342, -123));
	    break;

	case "mp_shrine":
			level thread spawnScriptModel((-760, -1073, 15.5));
    			level thread spawnScriptModel((-2116, 937.5, -135));
    			level thread spawnScriptModel((-3808, 845.5, -92));

    			level thread spawnScriptModel((-2163, 707, -301.5));
    			level thread spawnScriptModel((-72, 496, -248));
    			level thread spawnScriptModel((-2451, -72.5, -409.5));
    			level thread spawnScriptModel((-1464, 1329, -17));
    			level thread spawnScriptModel((-1259, 1279, -17));
    			level thread spawnScriptModel((-1880.5, 672, -152));
	    break;

	case "mp_nachtfeuer":
			level thread spawnScriptModel((232, -323, 1211));
    			level thread spawnScriptModel((318, -320, 1414));
    			level thread spawnScriptModel((318, -320, 1286));
    			level thread spawnScriptModel((1052, -752, 1300));
    			level thread spawnScriptModel((-820, 1602, 1348));
	    break;

	case "mp_downfall":
			level thread spawnScriptModel((-1214, 8213, -50.5));
    			level thread spawnScriptModel((-758, 7611, 122));
    			level thread spawnScriptModel((360, 6642, 52));
    			level thread spawnScriptModel((909, 6672, 44));
    			level thread spawnScriptModel((798, 6676, 42));
			level thread spawnScriptModel((4629.5, 8539.5, -112.5));
    			level thread spawnScriptModel((4555.5, 8295.5, -112.5));
    			level thread spawnScriptModel((3821, 10522, -133));
    			level thread spawnScriptModel((2786, 8295, 104));
    			level thread spawnScriptModel((2744, 9148, 104));
	    break;

	case "mp_hangar":
			level thread spawnScriptModel((-949.5, 22, 1045.25));
    			level thread spawnScriptModel((-41, -136, 908));
    			level thread spawnScriptModel((-384, -2451, 1136));
    			level thread spawnScriptModel((-1613, -842, 852));
    			level thread spawnScriptModel((-366, -2026, 652));
			level thread spawnScriptModel((-320, -2480, 892));
    			level thread spawnScriptModel((64, -80, 848));
    			level thread spawnScriptModel((3821, 10522, -133));
    			level thread spawnScriptModel((2786, 8295, 104));
    			level thread spawnScriptModel((2744, 9148, 104));
	    break;

	case "mp_makin":
		   	level thread spawnScriptModel((-7608.5, -16543, 371));
    			level thread spawnScriptModel((-10085, -14817, 129));
    			level thread spawnScriptModel((-10072, -16352, 185));
    			level thread spawnScriptModel((-9617, -17242, 407));
    			level thread spawnScriptModel((-9961, -14426, 172));
			level thread spawnScriptModel((-9720, -14613, 182));
    			level thread spawnScriptModel((-7967.5, -16214, 270.5));
    			level thread spawnScriptModel((-11892, -16454, -68));
    			level thread spawnScriptModel((-12015, -16587, -68));
    			level thread spawnScriptModel((-11054, -15549, 23));
    			level thread spawnScriptModel((-9895.5, -16100, 223.5));
    			level thread spawnScriptModel((-9590, -15890, 240));
	    break;

    }
}
DisplayBarrierPostoggle()
{
    if(level.BarrierPos == false)
    {
        self iPrintlnBold("^7Barriers Orbs Turned ^2On!");
        level.BarrierPos = true;
	level thread DisplayBarrierPos();
	
    }
    else
    {
        self iPrintlnBold("^7Barrier Orbs Turned ^1Off");
        level.BarrierPos = false;
	level notify("EndBarrierEnts");
	
    }
}